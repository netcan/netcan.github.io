---
title: C++20åç¨‹
toc: true
original: true
date: 2020-09-05 14:36:19
tags:
- C/C++
- åç¨‹
categories:
- å­¦ä¹ ç¬”è®°
---

C++20ç»ˆäºå¼•å…¥äº†åç¨‹ç‰¹æ€§ï¼Œç»™åº“ä½œè€…æä¾›äº†ä¸€ä¸ªå®ç°åç¨‹çš„æœºåˆ¶ï¼Œè®©ç”¨æˆ·æ–¹ä¾¿ä½¿ç”¨åç¨‹æ¥ç¼–å†™å¼‚æ­¥é€»è¾‘ï¼Œé™ä½äº†å¼‚æ­¥å¹¶å‘ç¼–ç¨‹çš„éš¾åº¦ã€‚ç»“åˆæˆ‘æœ€è¿‘åç¨‹çš„å­¦ä¹ ï¼Œåœ¨è¿™é‡Œè®°å½•ä¸€ä¸‹ç›¸å…³å†…å®¹ã€‚

## ä½¿ç”¨åœºæ™¯
åç¨‹å’Œæ™®é€šå‡½æ•°ç›¸æ¯”ï¼Œå¤šäº†ä¸ªä¸­é€”éšæ—¶**æŒ‚èµ·**ï¼Œéšå**æ¢å¤**çš„è¿‡ç¨‹ï¼Œå½“ç”¨æˆ·è°ƒç”¨ä¸€ä¸ªé˜»å¡è¯·æ±‚æ¥å£ï¼Œä»è€Œè®©å‡ºæ§åˆ¶æƒï¼Œå½“å“åº”æ—¶ï¼Œæ¢å¤ä¹‹å‰çš„æ§åˆ¶æµï¼Œä»è€Œå¤§å¤§æé«˜çº¿ç¨‹å¤ç”¨ç‡ï¼Œè¿™ä¹Ÿæ³¨æ„äº†åç¨‹åªæ˜¯å¹¶å‘çš„ï¼Œå¹¶ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„å¹¶è¡Œï¼Œåœ¨IOå¯†é›†å‹åœºæ™¯ä¸‹ï¼Œåç¨‹èƒ½å¤Ÿå¾ˆå¥½çš„æé«˜èµ„æºåˆ©ç”¨ç‡ï¼Œç”¨å°‘æ•°çš„çº¿ç¨‹è¾¾åˆ°å¹¶å‘æˆç™¾ä¸Šä¸‡ä¸ªåç¨‹çš„æ•ˆæœã€‚

è€Œç›¸å¯¹ä¼ ç»Ÿçš„çº¿ç¨‹æ± +å›è°ƒæ¨¡å¼ï¼Œæ¯å‘èµ·ä¸€ä¸ªè¯·æ±‚ï¼Œä¸ºäº†é¿å…é˜»å¡å½“å‰çº¿ç¨‹ï¼Œéœ€è¦æŒ‚ä¸€ä¸ªå›è°ƒå‡½æ•°å¤„ç†åç»­è¿‡ç¨‹ï¼Œè€Œå›è°ƒå‡½æ•°åˆå¯èƒ½äº§ç”Ÿç«äº‰ï¼Œå¯¼è‡´å¾—åŠ é”å¤„ç†ã€‚è€Œåç¨‹å´èƒ½å¤Ÿä»¥åŒæ­¥æ–¹å¼å†™å®ç°å¼‚æ­¥ï¼Œåç»­è¿‡ç¨‹ç›´æ¥æŒ‚èµ·ï¼Œå½“å“åº”çš„æ—¶å€™æ¢å¤æ‰§è¡Œã€‚

æˆ‘å‚ä¸çš„é¡¹ç›®ä¸­ï¼Œå¯¹è±¡éšæ—¶éƒ½å¯èƒ½èµ·ä¸ªçº¿ç¨‹å¹²æ´»ï¼Œæˆ–è€…å¸¸é©»äºå¯¹è±¡ç”Ÿå‘½å‘¨æœŸé‡Œï¼Œç»Ÿè®¡ä¸‹æ¥æ•´ä¸ªé¡¹ç›®å±…ç„¶å¼€äº†å‡ ç™¾ä¸ªçº¿ç¨‹ï¼Œç”±äºå¤šçº¿ç¨‹ç¼–ç¨‹éš¾å…å¯¼è‡´ç«äº‰ï¼Œä»è€Œéœ€è¦é”è¿™ç§å¾ˆä½çº§çš„æœºåˆ¶åšåŒæ­¥ï¼Œè€Œä¸€æ—¦å¼•å…¥äº†é”ï¼Œå°±ä¸å¯é¿å…çš„æ‰©æ•£å¼€æ¥ï¼Œå¤§å®¶çœ‹åˆ°è¿™é‡ŒåŠ æŠŠé”ï¼Œé‚£æˆ‘ä¹ŸåŠ æŠŠé”ï¼Œç»Ÿè®¡ä¸‹æ¥ä»£ç é‡Œé¢å±…ç„¶ä¹Ÿæœ‰å‡ ç™¾æŠŠé”ã€‚ã€‚çœŸæ˜¯ç»´æŠ¤çš„å™©æ¢¦å•ŠğŸ¤£

ç”±äºåç¨‹èƒ½å¤Ÿéšæ—¶æŒ‚èµ·ï¼Œåç»­æ¢å¤ï¼Œè¿™å°±èƒ½å®ç°ä¸€äº›å»¶è¿Ÿè®¡ç®—çš„ç‰¹æ€§ï¼Œä¾‹å¦‚ç”Ÿæˆå™¨ã€‚

æ‰¯è¿œäº†ï¼Œæœ¬æ–‡ä¸»é¢˜æ˜¯å…³äºC++20çš„åç¨‹ï¼Œåœ¨C++20è¿˜æ²¡ç¨³å®šä¹‹å‰ï¼Œå…ˆæ¥å­¦ä¹ ä¸€ä¸‹ç›¸å…³çŸ¥è¯†ï¼Œè¯»å®Œæœ¬æ–‡åä½ åº”è¯¥èƒ½åˆ©ç”¨è¿™ä¸ªæœºåˆ¶å®ç°ä¸€äº›æƒ³è¦çš„åç¨‹äº†ã€‚

## æ¦‚å¿µæ¨¡å‹
C++20çš„åç¨‹è®¾è®¡ä¸ºæ— æ ˆåç¨‹ï¼Œç›¸å¯¹äºæœ‰æ ˆåç¨‹ï¼Œçœæ‰äº†ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€[^1]ï¼Œåªèƒ½æ‰‹åŠ¨åˆ‡æ¢ï¼Œæ•ˆç‡æ›´é«˜ï¼Œä¹Ÿä¸ç”¨ç®¡ç†å¤æ‚çš„å¯„å­˜å™¨çŠ¶æ€ï¼Œç§»æ¤æ€§æ›´å¥½ï¼Œä½†è¿™åŒæ—¶ä¹Ÿå¯¼è‡´äº†ä¸èƒ½è¢«éåç¨‹å‡½æ•°åµŒå¥—è°ƒç”¨ã€‚

åŒæ—¶å¼•å…¥äº†3ä¸ªå…³é”®å­—ï¼š

- co_yield: æŒ‚èµ·å¹¶è¿”å›å€¼
- co_await: æŒ‚èµ·
- co_return: ç»“æŸåç¨‹

å½“ä¸€ä¸ªå‡½æ•°å‡ºç°äº†ä¸Šé¢çš„å…³é”®å­—ï¼Œåˆ™è¯¥å‡½æ•°æ˜¯ä¸ªåç¨‹ã€‚

### Promise
å½“callerè°ƒç”¨ä¸€ä¸ªcalleeåç¨‹çš„æ—¶å€™ï¼Œåç¨‹è‡ªèº«çš„çŠ¶æ€ä¿¡æ¯[^2]ï¼ˆå½¢å‚ï¼Œå±€éƒ¨å˜é‡ï¼Œè‡ªå¸¦æ•°æ®ï¼Œå„ä¸ªé˜¶æ®µç‚¹æ‰§è¡Œç‚¹ï¼‰ä¼šè¢«ä¿å­˜åœ¨å †ä¸Šçš„Promiseå¯¹è±¡ä¸­ï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨ä¼šåœ¨åç¨‹é‡Œé¢æ’å…¥Promiseç›¸å…³ä»£ç ï¼Œä»¥åŠä¸€äº›æ‰§è¡Œç‚¹ã€‚ç”±äºPromiseçš„å¤§å°å¯ä»¥åœ¨ç¼–è¯‘æœŸè®¡ç®—å‡ºæ¥ï¼Œä»è€Œé¿å…äº†å†…å­˜æµªè´¹ã€‚è€ŒPromiseå¯¹è±¡æ‰€æœ‰æƒå¯ç”±`coroutine_handle`å¥æŸ„æŒæœ‰ã€‚

### Future
è€ŒFutureå¯¹è±¡ä¸»è¦æ˜¯ä¸Promiseå¯¹è±¡äº¤äº’çš„æ¡¥æ¢ï¼Œæ—¢callerä¸calleeä¹‹é—´çš„é€šä¿¡ï¼š

- calleeæŒ‚èµ·æ—¶ï¼Œå°†å€¼è¿”å›ç»™caller: yieldè¯­ä¹‰
- calleeæ‰§è¡Œç»“æŸæ—¶ï¼Œå°†å€¼è¿”å›ç»™caller: returnè¯­ä¹‰
- calleeæ¢å¤æ—¶ï¼Œcallerå°†å€¼å¸¦ç»™callee

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™äº›æ¦‚å¿µå’Œæ ‡å‡†åº“çš„`std::promise/std::future`ä¸æ˜¯åŒä¸€ä¸ªä¸œè¥¿ï¼Œåè€…ç”¨äºåšåŒæ­¥ç”¨ï¼Œ`std::future`ä¼šé˜»å¡ç­‰å¾…ç›´åˆ°`std::promise`æä¾›å€¼ï¼Œå¯ä»¥çœ‹åšæ˜¯æ¡ä»¶å˜é‡çš„å°è£…ï¼ŒåŒæ ·åœ°ï¼Œå’Œå…¶ä»–è¯­è¨€çš„Promise/Futureæ¦‚å¿µä¹Ÿä¸ä¸€æ ·ã€‚

### Awaitable
å¦‚æœä¸€ä¸ªå¯¹è±¡æ˜¯Awaitableå¯¹è±¡ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨co_awaitæ“ä½œç¬¦å»è§¦å‘è¯¥å¯¹è±¡çš„åŠ¨ä½œready/suspend/resumeï¼Œä»è€Œè½¬ç§»ã€æ¢å¤æ§åˆ¶æƒï¼Œco_awaitç»†èŠ‚ç•™åˆ°åé¢åœ¨ä»‹ç»ã€‚

## å…·ä½“æœºåˆ¶
äº†è§£äº†æ¦‚å¿µæ¨¡å‹åï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥æ¢è®¨èƒŒåçš„æœºåˆ¶äº†ã€‚

### Promise/Futureå¯¹è±¡
å½“ä¸€ä¸ªåç¨‹è¢«è°ƒç”¨æ—¶ï¼Œä¼šåˆ›å»ºPromiseå¯¹è±¡ï¼Œç„¶åç¼–è¯‘å™¨ä¼šåœ¨å„ä¸ªé˜¶æ®µæ’å…¥ä¸€äº›ä»£ç [^3]ï¼š

```cpp
{
  co_await promise.initial_suspend();
  try
  {
    <body-statements>
  }
  catch (...)
  {
    promise.unhandled_exception();
  }
FinalSuspend:
  co_await promise.final_suspend();
}
```

å¯ä»¥çœ‹åˆ°ä¸€ä¸ªåç¨‹å‡½æ•°ï¼Œåˆ†ä¸ºå¦‚ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

1. ä»å †ä¸Š(operator new)åˆ›å»ºPromiseå¯¹è±¡ï¼Œä¿å­˜åç¨‹çš„çŠ¶æ€ä¿¡æ¯
2. initial_suspendé˜¶æ®µï¼Œç”¨äºåœ¨æ‰§è¡Œåç¨‹ä¸»ä½“`<body-statements>`ä»£ç å‰åšäº›äº‹æƒ…
3. `<body-statements>`é˜¶æ®µï¼Œæ‰§è¡Œåç¨‹çš„ä¸»ä½“ä»£ç 
4. unhandled_exceptioné˜¶æ®µï¼Œè‹¥æŠ›å¼‚å¸¸ï¼Œå¤„ç†å¼‚å¸¸
5. final_suspendé˜¶æ®µï¼Œåç¨‹ç»“æŸæ”¶å°¾åŠ¨ä½œï¼Œåœ¨è¿™é˜¶æ®µçš„`coroutine_handle<Promise>::done`æ–¹æ³•ä¸ºtrueï¼Œcallerå¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹æ³•åˆ¤æ–­åç¨‹æ˜¯å¦ç»“æŸï¼Œä»è€Œä¸å†è°ƒç”¨resumeæ¢å¤åç¨‹

è€Œåç¨‹è¿”å›ç±»å‹åˆ™æ˜¯ä¸€ä¸ªFutureå¯¹è±¡ï¼Œè¿™ä¸€æ­¥ç¼–è¯‘å™¨é€šè¿‡`Promise::get_return_object()`æ¥åˆ›å»ºFutureå¯¹è±¡ã€‚è€ŒFutureå¯¹è±¡ä¸€èˆ¬æŒæœ‰Promiseçš„å¥æŸ„ï¼š`coroutine_handle<Promise>`ï¼Œè¿™æ ·callerå¯ä»¥é€šè¿‡Futureä¸Promiseäº¤äº’ï¼Œä»è€Œæ¢å¤åç¨‹ã€‚

è€ŒPromiseå¯¹è±¡é‡Šæ”¾çš„æ—¶é—´ç‚¹æœ‰ä¸¤ä¸ªï¼Œé¿å…é‡å¤æ‰§è¡Œï¼Œå¦åˆ™ä¼šdouble freeï¼š

- final_suspendé˜¶æ®µresumeå
- è°ƒç”¨`coroutine_handle<Promise>::destroy()`æ–¹æ³•

æ¯”è¾ƒå¥½çš„åšæ³•æ˜¯åœ¨final_suspendé˜¶æ®µæŒ‚èµ·ï¼Œè¿™æ—¶å€™å°±ä¸å¯resumeäº†ï¼Œåœ¨calleré€šè¿‡è°ƒç”¨FutureæŒæœ‰çš„å¥æŸ„`destroy()`æ–¹æ³•é‡Šæ”¾Promiseå¯¹è±¡ã€‚

ç»¼ä¸Šï¼Œä¸€ä¸ªPromiseå¯¹è±¡éœ€è¦å®ç°å¦‚ä¸‹æ–¹æ³•ï¼š

- initial_suspend: è¿”å›ä¸€ä¸ªAwaitableå¯¹è±¡
- final_suspend: è¿”å›ä¸€ä¸ªAwaitableå¯¹è±¡
- get_return_object: è¿”å›ä¸€ä¸ªFutureå¯¹è±¡ç»™caller
- unhandled_exception: å¤„ç†å¼‚å¸¸
- return_value/return_void: co_returnæ—¶è¿”å›å€¼ç»™caller
- yield_value: æŒ‚èµ·æ—¶è¿”å›å€¼ç»™caller

å†æ¥çœ‹çœ‹å…¶`coroutine_handle<Promise>`å¥æŸ„ç¼–è¯‘å™¨æä¾›äº†å“ªäº›ä¸»è¦æ–¹æ³•ï¼š

- destroy: é”€æ¯Promiseå¯¹è±¡
- from_promise: é™æ€æ–¹æ³•ï¼Œä»Promiseå¯¹è±¡è¿”å›å…¶`coroutine_handle`å¥æŸ„
- done: æ˜¯å¦å¤„äºfinal_suspendé˜¶æ®µ
- promise: è¿”å›Promiseå¯¹è±¡å¼•ç”¨
- resume/operator(): æ¢å¤åˆ°åç¨‹

### Awaitableå¯¹è±¡
å‰é¢æåˆ°çš„co_awaitå…³é”®å­—[^4]ï¼Œå…¶æ“ä½œçš„å¯¹è±¡å…¶å®æ˜¯Awaiterå¯¹è±¡ï¼Œè‹¥å¯¹è±¡å®ç°å¦‚ä¸‹æ–¹æ³•ï¼Œåˆ™è¯´æ˜è¯¥å¯¹è±¡æ˜¯Awaitableçš„ï¼š

- await_ready
- await_suspend(`coroutine_handle<>`)
- await_resume

é‚£ä¹ˆå½“æ‰§è¡Œ`co_await <expr>`è¡¨è¾¾å¼æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š
```cpp
{
  auto&& value = <expr>;
  auto&& awaitable = get_awaitable(promise, static_cast<decltype(value)>(value));
  auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));
  if (!awaiter.await_ready())
  {
    <suspend-coroutine>

    //if await_suspend returns void
    try {
        awaiter.await_suspend(coroutine_handle);
        return_to_the_caller();
    } catch (...) {
        exception = std::current_exception();
        goto resume_point;
    }
    //endif
    //if await_suspend returns bool
    bool await_suspend_result;
    try {
        await_suspend_result = awaiter.await_suspend(coroutine_handle);
    } catch (...) {
        exception = std::current_exception();
        goto resume_point;
    }
    if (not await_suspend_result)
        goto resume_point;
    return_to_the_caller();
    //endif
    //if await_suspend returns another coroutine_handle
    decltype(awaiter.await_suspend(std::declval<coro_handle_t>())) another_coro_handle;
    try {
        another_coro_handle = awaiter.await_suspend(coroutine_handle);
    } catch (...) {
        exception = std::current_exception();
        goto resume_point;
    }
    another_coro_handle.resume();
    return_to_the_caller();
    //endif
  }
  resume_point:
if(exception)
  std::rethrow_exception(exception);
"return" awaiter.await_resume();
}
```

ä¹Ÿå°±æ˜¯ï¼š

1. é€šè¿‡`<expr>`æ‹¿åˆ°Awaiterå¯¹è±¡
2. é€šè¿‡Awaiter.await_ready()æ–¹æ³•åˆ¤æ–­æ˜¯å¦éœ€è¦æŒ‚èµ·ï¼Œè‹¥ä¸ºtrueåˆ™æ— éœ€æŒ‚èµ·
3. åˆ¤æ–­Awaiter.await_suspend()çš„è¿”å›å€¼ç±»å‹ï¼š
    - voidï¼Œæ— è¿”å›å€¼ï¼Œç›´æ¥æŒ‚èµ·è¿”å›caller
    - boolï¼Œè‹¥ä¸ºtrueï¼Œåˆ™è¿”æŒ‚èµ·è¿”å›callerï¼Œå¦åˆ™ä¸æŒ‚èµ·ï¼Œç›´æ¥resume
    - `coroutine_handle<>`, åˆ™æŒ‚èµ·å¹¶å°†æ§åˆ¶æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªåç¨‹ä¸Šï¼Œå¦ä¸€ä¸ªåç¨‹å¯ä»¥å†resumeå›æ¥ï¼Œåˆ°è¾¾`resume_point`ã€‚
4. Awaiter.await_resume()çš„è¿”å›å€¼å³ä¸ºco_awaitçš„ç»“æœ

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè°æ¥åˆ›å»ºAwaiterå¯¹è±¡å‘¢ï¼Ÿæœ‰ä¸¤ç§æ–¹æ³•ï¼š

1. é€šè¿‡Promiseå¯¹è±¡çš„`await_transform(<expr>)`æ–¹æ³•ï¼Œå¾—åˆ°Awaiterå¯¹è±¡
2. é€šè¿‡é‡è½½operator co_awaitæ“ä½œç¬¦ï¼Œå¾—åˆ°Awaiterå¯¹è±¡
3. ç›´æ¥ç”¨Awaitableå¯¹è±¡

æ ‡å‡†åº“é‡Œé¢å®ç°äº†ä¸¤ç§Awaiterï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼š
```cpp
struct suspend_never {
  bool await_ready() const { return true; }
  void await_suspend(coroutine_handle<>) const {}
  void await_resume() const {}
};

struct suspend_always {
  bool await_ready() const { return false; }
  void await_suspend(coroutine_handle<>) const {}
  void await_resume() const {}
};

```

ä¸»è¦åœ¨`await_ready`é˜¶æ®µåˆ¤æ–­æ˜¯å¦éœ€è¦æŒ‚èµ·åç¨‹ã€‚

æœ€å`co_yield <expr>`å…¶å®æ˜¯co_awaitçš„è¯­æ³•ç³–ï¼Œç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š
```cpp
co_await promise.yield_value(expression);
```

è€Œco_returnåˆ™ä¼šè°ƒç”¨Promiseå¯¹è±¡çš„return_void/return_valueæ–¹æ³•ã€‚

## åç¨‹å®æˆ˜
æœ‰äº†ä»¥ä¸ŠçŸ¥è¯†ï¼Œåº”è¯¥è¶³å¤Ÿå®ç°ä¸€äº›åç¨‹äº†ã€‚

ä¸ºäº†ç®€å•èµ·è§ï¼Œè¿™é‡Œæˆ‘å®ç°ä¸€ä¸ªFibonacciçš„ç”Ÿæˆå™¨ï¼Œå®Œæ•´ä»£ç å¯ä»¥è§ï¼š
[https://github.com/netcan/recipes/blob/master/cpp/coroutine/FibonacciGen.cpp](https://github.com/netcan/recipes/blob/master/cpp/coroutine/FibonacciGen.cpp)

é¦–å…ˆå…ˆå†™åç¨‹å‡½æ•°ï¼Œå¹¶åœ¨main callerä¸­è°ƒç”¨ï¼Œå†…å®¹å¦‚ä¸‹ï¼š
```cpp
FiboFuture generate_fibo() {
    int i = 0, j = 1;
    while (true) {
        co_yield j;
        std::tie(i, j) = std::make_pair(j, i + j);
    }
}

int main() {
    for (auto x = generate_fibo(); x < 1000; x.resume())
        std::cout << "fibo: " << x << std::endl;
    return 0;
}
```

æ¥ç€å®ç°æˆ‘ä»¬æ‰€éœ€è¦çš„Proimseå¯¹è±¡ï¼Œç”¨äºå°†ç»“æœä¼ ç»™callerï¼š
```cpp
struct promise_type {
    int value_; // è¿”å›ç»“æœç»™caller
    auto initial_suspend() { return suspend_never{}; }
    auto final_suspend() noexcept { return suspend_always{}; } // final_suspendæŒ‚èµ·ï¼Œç”±FiboFutureé‡Šæ”¾promiseå¯¹è±¡
    FiboFuture get_return_object()
    { return {coroutine_handle<promise_type>::from_promise(*this)}; } // è¿”å›FiboFutureå¯¹è±¡
    void unhandled_exception() { std::terminate(); }

    auto yield_value(int value) { // yieldä¸€ä¸ªå€¼å¹¶æŒ‚èµ·è¿”å›caller
        value_ = value;
        return suspend_always{};
    }
    void return_void() {}
};
```

è¿˜æœ‰å¯¹åº”çš„Futureï¼š
```cpp
struct FiboFuture {
    struct promise_type;
    FiboFuture(coroutine_handle<promise_type> handle): handle_(handle) {}

    operator int() { return handle_.promise().value_; }
    void resume() { if (! handle_.done()) handle_.resume(); }
    ~FiboFuture() { handle_.destroy(); }
private:
    coroutine_handle<promise_type> handle_;
};
```

ä¸€åˆ‡æå®šï¼Œè¿™å°±æ˜¯ç›®å‰ç”Ÿæˆå™¨çš„å®ç°ï¼Œå¾…åç»­é›†æˆåˆ°æ ‡å‡†åº“ä¸­å»ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚

è¿˜æœ‰ä¸€ä¸ªä¾‹å­æ˜¯caller/calleeç›¸äº’åä½œï¼Œäº’ç›¸é€šä¿¡å®Œæˆä»»åŠ¡ï¼Œå…·ä½“è§ï¼š
[https://github.com/netcan/recipes/blob/master/cpp/coroutine/DoubleClick.cpp](https://github.com/netcan/recipes/blob/master/cpp/coroutine/DoubleClick.cpp)

## æ€»ç»“
æœŸå¾…C++20åç¨‹çš„ç¨³å®šæˆç†Ÿï¼Œè¿™æ ·å†™ä¸šåŠ¡ä»£ç å°±ç®€å•å¤šäº†ï¼Œå¿ƒæ™ºè´Ÿæ‹…æ²¡é‚£ä¹ˆé‡äº†ã€‚

[^1]: [æœ‰æ ˆåç¨‹ä¸æ— æ ˆåç¨‹](https://mthli.xyz/stackful-stackless/)
[^2]: [Introduction to C++ Coroutines - James McNellis](https://github.com/CppCon/CppCon2016/blob/master/Presentations/Introduction%20to%20C%2B%2B%20Coroutines/Introduction%20to%20C%2B%2B%20Coroutines%20-%20James%20McNellis%20-%20CppCon%202016.pdf)
[^3]: [C++ Coroutines: Understanding the promise type](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type)
[^4]: [CO_AWAITING COROUTINES](https://blog.panicsoftware.com/co_awaiting-coroutines/)
