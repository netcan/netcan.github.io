<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>如何出版一本技术图书 -- 写在《C++20 高级编程》出版之时 | Netcan on Programming</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C/C++," />
  

  <meta name="description" content="《C++20 高级编程》介绍 我人生中第一本技术图书《C++20 高级编程》即将上市，由  机械工业出版社  出版，目前下单链接：https:&#x2F;&#x2F;item.jd.com&#x2F;10054930586115.html。 C++ 语言至今拥有 40 多年的历史，目前最新的 C++ 标准已经到了令人兴奋的 C++20，它给我们带来了相当重要的四大特性：概念约束、ranges（范围）标准库、协程以及模块：  概">
<meta property="og:type" content="article">
<meta property="og:title" content="如何出版一本技术图书 -- 写在《C++20 高级编程》出版之时">
<meta property="og:url" content="https://netcan.github.io/2022/06/22/%E5%A6%82%E4%BD%95%E5%87%BA%E7%89%88%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E5%9B%BE%E4%B9%A6-%E5%86%99%E5%9C%A8%E3%80%8AC-20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%87%BA%E7%89%88%E4%B9%8B%E6%97%B6/index.html">
<meta property="og:site_name" content="Netcan on Programming">
<meta property="og:description" content="《C++20 高级编程》介绍 我人生中第一本技术图书《C++20 高级编程》即将上市，由  机械工业出版社  出版，目前下单链接：https:&#x2F;&#x2F;item.jd.com&#x2F;10054930586115.html。 C++ 语言至今拥有 40 多年的历史，目前最新的 C++ 标准已经到了令人兴奋的 C++20，它给我们带来了相当重要的四大特性：概念约束、ranges（范围）标准库、协程以及模块：  概">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-22T10:29:34.000Z">
<meta property="article:modified_time" content="2022-12-09T11:02:08.588Z">
<meta property="article:author" content="Netcan">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/site.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-174901164-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d2c292719a76d8c0fa7f9874379cfd25";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Netcan on Programming" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">ROOT</span>
  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/>
<link rel="stylesheet" href="/css/prism.css">

<div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">ROOT</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%8AC-20%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">《C++20 高级编程》介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E7%BB%93%E6%9E%84"><span class="toc-text">本书结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">类型与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-text">编译时多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E7%BA%A6%E6%9D%9F"><span class="toc-text">概念约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">元编程介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-text">模板元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%20%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-text">constexpr 元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ranges%20%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">Ranges 标准库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B"><span class="toc-text">无栈协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-text">模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8"><span class="toc-text">综合运用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E5%BA%8F%EF%BC%88%E5%90%B4%E5%92%8F%E7%82%9C%EF%BC%89"><span class="toc-text">推荐序（吴咏炜）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E8%AF%84%E8%AE%BA"><span class="toc-text">本书评论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%B4%E5%92%8F%E7%82%9C%EF%BC%8CBoolan-%20%E9%A6%96%E5%B8%AD%E5%92%A8%E8%AF%A2%E5%B8%88%EF%BC%8C%E5%9B%BD%E5%86%85%E7%9F%A5%E5%90%8D%20-C-%20%E4%B8%93%E5%AE%B6"><span class="toc-text">吴咏炜，Boolan 首席咨询师，国内知名 C++ 专家</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%81%E8%8B%B1%E6%9D%B0%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%92%A8%E8%AF%A2%E5%B8%88%EF%BC%8CC-%20%E8%B5%84%E6%B7%B1%E4%B8%93%E5%AE%B6"><span class="toc-text">袁英杰，软件架构咨询师，C++ 资深专家</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B8%E8%83%9C%E5%86%9B%EF%BC%8C%E5%8D%8E%E4%B8%BA%20Camera%20%E9%A2%86%E5%9F%9F%E8%B5%84%E6%B7%B1%E8%BD%AF%E4%BB%B6%E4%B8%93%E5%AE%B6"><span class="toc-text">许胜军，华为 Camera 领域资深软件专家</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%99%E5%AD%9F%E8%B6%8A%EF%BC%8C%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%EF%BC%8C%E7%BD%A1%E5%85%B4%E6%8A%95%E8%B5%84%E9%87%8F%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%BB%E7%9B%91"><span class="toc-text">孙孟越，清华大学，罡兴投资量化开发总监</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E7%BC%96%E5%86%99%E6%9C%AC%E4%B9%A6%EF%BC%9F"><span class="toc-text">为何编写本书？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E5%8B%98%E8%AF%AF"><span class="toc-text">本书勘误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-如何出版一本技术图书-写在《C-20高级编程》出版之时" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">如何出版一本技术图书 -- 写在《C++20 高级编程》出版之时</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2022.06.22</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Netcan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="《C-20 高级编程》介绍">《C++20 高级编程》介绍</h2>
<p>我人生中第一本技术图书《C++20 高级编程》即将上市，由 <strong> 机械工业出版社 </strong> 出版，目前下单链接：<a target="_blank" rel="noopener" href="https://item.jd.com/10054930586115.html">https://item.jd.com/10054930586115.html</a>。</p>
<p>C++ 语言至今拥有 40 多年的历史，目前最新的 C++ 标准已经到了令人兴奋的 C++20，它给我们带来了相当重要的四大特性：概念约束、ranges（范围）标准库、协程以及模块：</p>
<ul>
<li><strong>概念约束 </strong> 是一个编译期谓词，它根据程序员定义的<strong> 接口规范 </strong> 对类型、常量等进行编译时检查，以便在泛型编程中提供更好的可读性与错误信息；</li>
<li><strong>ranges 标准库 </strong> 对现有的标准库进行了补充，它以函数式编程范式进行编程，将计算任务由一系列原子操作灵活组合而成，使得代码的正确性更<strong> 容易推理</strong>；</li>
<li><strong>协程 </strong> 是一种可挂起可恢复的通用函数，它的切换开销是<strong> 纳秒 </strong> 级的，相对其他方案而言占用极低的资源，并且可以非侵入式地为已有库扩展协程接口，它常常用于并发编程、生成器、流处理、异常处理等；</li>
<li><strong>模块特性</strong> 解决了传统上头文件编译模型的痛点：依赖顺序导致头文件难以组合、重复地解析、符号覆盖等问题，它从语言层面为程序员提供了模块化的手段。</li>
</ul>
<p>本书将深入这些新特性，笔者为它们准备了 <strong> 丰富 </strong> 的代码样例，通过这些代码相信读者很容易掌握这些特性。作为一本讲解 C++ 高级编程的书，笔者还探讨很多 <strong> 元编程 </strong> 话题，这是作为 <strong> 库开发 </strong> 必不可少的技能，它们也随着 C++ 的演进而不断演进，大大提高了库开发者的 <strong> 编程体验</strong>，尤其是近年来 C++ 的标准提案经历了从模板元编程向 constexpr 元编程转换过程。</p>
<p>纵观 C++ 的演进历程可以发现，每一次演进提供的特性大多数和 <strong> 编译时 </strong> 相关，因为它的特点是 <strong> 零成本抽象 </strong>，允许程序员表达抽象的概念而无需忍受<strong> 不必要的运行时开销 </strong>。而一些运行时特性相当少，在面向对象的虚函数特性之后再无运行时特性，或者它们通常以<strong> 库</strong> 的形式提供，例如 C++17 起标准库引入的 variant 类型，它通过元编程技术生成虚函数表。</p>
<p>C++ 对语言特性与库特性区分的非常清楚，它希望程序员能够在不引入语言机制的情况下实现一些功能，例如其他编程语言常常将元组 tuple 作为内建类型，而在 C++ 中它们以库的方式提供，程序员能够利用现有的语言特性实现这些组件。</p>
<p>如何合理的、高效的运用这些知识，它们背后通常蕴含着什么指导思想？那就是 <strong> 组合式 </strong> 思想，将问题分而治之，它能够应对许多难题。C++ 语言提供了足够多的 <strong> 抽象机制 </strong>，允许程序员提出各种<strong> 假设 </strong>，并基于这些假设进行<strong> 灵活组合</strong>。</p>
<p>本书话题不局限于 C++20，现代 C++ 中一些很多重要的特性也会深入探讨，例如右值引用。一些编程原则，面向对象设计模式也会探讨。最后一章带领读者实现两个库：配置文件反序列库与协程库，它们大量使用 C++20 提供的特性，并使用元编程的方式构建，以对全书知识进行一个总结。</p>
<p>本书要求读者需要有 C++ 的基础知识，最好能够掌握一些现代 C++ 的知识，考虑到市面上的书籍以及网络上这方面的资料比较丰富，笔者在提及会引用相关链接供读者查阅。想要系统性的学习 C++20，并进阶 C++ 的技能，那么一定不要错过本书。</p>
<h2 id="本书结构">本书结构</h2>
<p>笔者成书、编程环境采用 Debian bookworm/macOS Monterey/Windows 10 操作系统，编译器用的是 GCC 12.0.0/Clang 14.0.0/MSVC 19.30，采用 <code>-std=c++2a</code>、<code>/std:c++20</code>编译选项，请读者自行安装这几个编译器。</p>
<p>在代码风格上，笔者力求代码简洁、精巧，例如花括号通常不独立成行，它们常常被压缩成一行；采用两空格缩进等。</p>
<p>全书共分为十章，C++20 的四大特性独立成章，一些小的特性则贯穿于全书，其他章节则探讨了一些面向对象、元编程、函数式编程、并发编程等话题。章节之间尽可能地按照前后依赖顺序组织，读者可以选择从头读到尾，也可以选择感兴趣的部分阅读。</p>
<h3 id="类型与对象">类型与对象</h3>
<p>介绍了 C++ 的类型系统，读者应该能认识到类型在语言中的重要性，类型安全即防止因为类型导致的错误，紧接着介绍 C++ 对类型处理能力的演进过程。</p>
<p>值类别将表达式划分为左值、右值与将亡值，从而能够表达移动语义；为了解决泛型编程中因为值类别导致重复实现多遍的问题，引入转发引用与完美转发来保留其引用性质。</p>
<p>介绍了类型推导相关知识，这部分知识在库开发中相当重要。</p>
<p>函数对象是另一个重要的概念，使用 lambda 可以简化定义函数对象的难度，标准库提供的函数适配器也能达到运行时多态。</p>
<p>随着 <code>union</code> 特性的限制放开，对其封装的 <code>std::variant</code> 更容易地表达运行时值语义多态，这也补充了运行时多态手段。</p>
<p>最后也最为重要的是调试手段，合理利用可事半功倍。</p>
<h3 id="编译时多态">编译时多态</h3>
<p>介绍了 C++ 语言在编译期进行多态的手段，最常见的是函数重载机制，支持这个特性的语言相当少。</p>
<p>函数重载方式给开发人员很大的灵活性，同一个语义拥有不同的实现，交由编译器进行重载决策；操作符重载可以大大提升计算的表达力。灵活的同时带来的复杂度就是语言需要很复杂的规则进行决策。</p>
<p>模板函数在重载过程中可能因为模板参数替换过程中可能失败，而仅仅从候选集中删除该函数并不触发编译错误，利用这个特点开发人员可以基于模板类型的特征（type traits）选择最佳的实现，例如可以针对不同迭代器的特点决策出最优的算法。</p>
<p>通过函数重载机制衍生了一系列相关技术：使用 <code>enable_if</code> 进行模板类型约束；使用标签分发技术进行偏序决策。使用奇异递归模板模式可以实现代码复用，做到静态多态。</p>
<p>最后介绍表达式模板，在编译期构造表达式树进行延迟计算，避免一些中间计算产生的临时变量，并生成高效的代码。</p>
<p>这些技术或多或少都是因为语言上的缺失导致的变通办法，我们即将看到 C++20 提供的新特性将代替这些技术。</p>
<h3 id="概念约束">概念约束</h3>
<p>concept 非常容易地定义与使用，它解决了模板与泛型编程的很多痛点问题，极大改善了模板与泛型编程的代码质量。它就和基础的语言特性诸如函数、类一样，需要理解才能高效使用。</p>
<p>与未受约束的模板相比，它们没有引入额外的运行时开销。这也符合了 C++ 的设计原则，不要强迫程序员去做机器能做的更好的事，并且简单的事简单做，以及零成本抽象的哲学。它达到了最初所设想的 C++ 模板系统应有的样子，而不是语言特性的扩展。它以扩展 <code>transform</code> 变换算法结束这章。</p>
<h3 id="元编程介绍">元编程介绍</h3>
<p>元编程技术是由编译器在编译时解析执行代码，并生成最终代码、数据的技术，它是高性能库开发必不可少的技术，通过最少的代价实现更多的功能、满足更大的灵活性，同时最大化复用代码。元编程特性是 C++ 语言提供的最高抽象手段。这章为后续章节做铺垫。</p>
<h3 id="模板元编程">模板元编程</h3>
<p>C++ 使用模板做元编程拥有足够悠久的历史，并且语言的发展使得元编程的体验越来越好。它为框架、库的开发提供了强有力的手段，通常是零成本抽象的基础。</p>
<p>在 C++ 中我们能够与编译器交互的工具是类型，通过强大的类型系统能够在编译期完成许多工作，并且能够生成最终高效的代码，元编程的本质是类型计算。</p>
<p>它以两个例子结束这章：定义图 EDSL 语言并于编译时计算最短路径、编译时生成数据表。理智的程序员发现，尽管模板元编程有着各种问题，但仍比起其他方案要好。当然，C++ 程序员必须学会限制编译期计算和元编程的使用，只有在值得为了代码紧凑性、表达力和运行时性能才引用它们。</p>
<h3 id="constexpr 元编程">constexpr 元编程</h3>
<p>早在 2003 年，C++ 标准委员会提出了用于在 C++ 中进行常量表达式求值的一种根本不同且明显更好的机制。人们当时使用无类型的宏和简陋的 C 语言定义的常量表达式。另一些人则开始使用模板元编程来计算值，这既乏味又容易出错，<code>constexpr</code>一定程度上简化了元编程难度。</p>
<p>这章提供了 <code>constexpr</code> 元编程库，它将模板元编程数据结构 <code>TypeList</code> 以值的形式表达，并利用管道操作符组合对值进行编译时计算，然后使用它重构前一章的例子。最后以编译时操作、生成字符串为例结束这章。</p>
<h3 id="Ranges 标准库">Ranges 标准库</h3>
<p>ranges 正式成为 C++20 标准库中的一部分，它的出现代表了标准库自 98 年以来最大的转变。这是重新实现 C++ 标准库的第一步，在这个标准库中，除了迭代器之外，接口还按照 ranges 指定。</p>
<p>除了提供高质量的 ranges 标准库之外，还从语言层面上使用 concept 提供支持以验证机制的完备性。</p>
<p>range 是对一系列数据的抽象，它即可以是一个有界容器，也可以是一个无穷列表，只要有头有尾。一旦我们有了这种抽象，那么我们可以进一步构造 range 的适配器，它们能够被管道操作符进行组合，以便对数据进行灵活、优雅与有趣地处理，而这些处理是延迟计算的。</p>
<p>它使你的程序通过消除循环来避免大量的状态操作，程序涉及的状态越少，代码的正确性越容易推理，因此 bug 也越少。最后以矩阵乘法、日历库为例结束这章。</p>
<h3 id="无栈协程">无栈协程</h3>
<p>协程提供了一种协作式的多任务模型，在并发计算领域，它通常要比多线程或多进程要高效地多。C++20 中的协程仅仅提供了机制，而没有标准库的支持，这将可能留给下一个标准 C++23 中提供。</p>
<p>这章深入探讨了协程机制所要求的接口，以及相关概念。最后通过三个例子结束这章：生成器是协程的经典应用，它是理解协程机制的基础；利用协程机制非侵入式地扩展标准库 <code>async</code> 接口；利用它封装异常处理流程。</p>
<p>协程机制的理解难度非常大，笔者在此章耗时最长，最初我在 2020 年开始学习协程机制，编写此章的时候仍花了 3 个月时间，期间通过反反复复阅读现有资料，以及编写协程库加深理解。所以读者可能需要花点功夫才能熟练掌握它。</p>
<h3 id="模块">模块</h3>
<p>C++20 提供了模块特性，一个库与软件组件化的现代解决方案，它能够像头文件一样在源代码间共享符号，与头文件不同的地方在于，模块并不会泄露宏的定义以及一些私有实现细节。</p>
<p>模块容易被组合，它们能够精确地控制哪些接口需要暴露给导入它们的源文件，并且不会因为导入顺序、宏定义等改变一个模块的语义。</p>
<p>遗憾的是目前主流编译器中对模块的支持都不完备，因此这章对 C++ 模块的介绍比较保守，没有深入其中的细节，因为它们暂时还无法被验证。</p>
<h3 id="综合运用">综合运用</h3>
<p>本书最后一章将分享笔者的两个的工程项目，它们分别为配置文件反序列化框架与 AsyncIO 协程库，以便对全书的知识进行融会贯通，它们都重度依赖现代 C++ 提供的特性，尤其是在协程库中。</p>
<p>传统的使用配置文件的方式是每添加一个配置文件都需要程序员去手写解析配置文件到数据结构中的代码，这个过程极其乏味，且容易出错，通过框架为数据结构定义 Schema，元编程将能够生成读取的接口，避免了这个繁杂的过程。这部分讨论了静态反射话题，目前 C++ 标准仍没有提供静态反射机制，它依赖宏做代码片段生成。</p>
<p>AsyncIO 协程库是笔者仿照 Python 的标准协程库并使用 C++ 协程机制实现，它以单线程的事件驱动循环为根基，并在这基础之上封装协程表现层。在最后给出了协程的性能表现。</p>
<h2 id="推荐序（吴咏炜）">推荐序（吴咏炜）</h2>
<p>我跟罗能认识已经有一年多了。初次相识是在我的一次关于嵌入式系统的 C++ 重构演讲之后，他——和一些其他人一起——就在会后加了我的联系方式。不过，跟其他大部分人不同，我们之间一直确实在“联系”，而且是很频繁的双向联系。原因无他，我们都是真正的 C++ 和编程爱好者。他会把他的一些文章和代码发给我看，而我，在写了一些有（hěn）意（dé）思（yì）的代码和文章时，也会发给他交流。虽然他比我年轻了差不多一辈，但我在他面前并没有多少倚老卖老的资格，反而是有点身为前浪的压力。事实上，我有些实际的工作项目和演讲，已经借鉴了他的想法和代码。</p>
<p>有没有注意到我说的是“C++ 和编程爱好者”？罗能并不只会 C++，他对 Rust 和函数式编程语言（多半还有其他我不知道的语言）都有所涉猎。显然，C++ 仍是他看来最 <strong>有用</strong>（在没有更好的形容词的情况下，姑且这么说吧）的语言。所以，这本以 C++ 为主题的书，也就成了他的第一本关于编程的书籍。</p>
<p>C++20 是 C++ 在 C++11 之后最大的一次语言变革，里面引入了大量具有革命性的新特性。罗能从一个独特的视角，讲解了其中最重要的四大特性。虽然 C++20 的新特性不止这四种，但编程并不是只讲特性：罗能的独特着眼点在于外面讨论较少的一些高级编程技巧，尤其是模板元编程方面。这比起干巴巴地讨论语言特性，明显要有用得多——毕竟，参考资料我们从 cppreference.com 之类的网站上自己就能找到，而高手的心得并不常有。因此，他的内容编排，也不是基于语言特性，而更多是基于讲解高级编程的逻辑顺序。在讲解了所有这些高级编程的基本概念之后（包括 C++20 的新特性），他通过一章综合运用，把知识点串到一起，展示了非常有意思的实际项目应用。——学语言的关键（不管是编程语言，还是平时说的语言）在于应用，因此这样的讲解是能够真正展现现代 C++ 威力的。基于对高级编程及其应用的深入理解，他讲解相关的 C++ 特性，可谓得心应手、游刃有余。</p>
<p>罗能的书稿我完整地看了，也做了些小小的贡献。限于时间，我没有深入其中所有的细节，但我也已经从中感受到了他对 C++ 和编程的许多独特见解。不夸张地说，我在阅读中也学到了很多新东西。因此，我相信这本书对于 C++ 相关的编程爱好者，一定是有所裨益的——即使对编程老手都是如此。</p>
<p>是为序。</p>
<h2 id="本书评论">本书评论</h2>
<h3 id="吴咏炜，Boolan- 首席咨询师，国内知名 -C- 专家">吴咏炜，Boolan 首席咨询师，国内知名 C++ 专家</h3>
<p>C++20 是 C++ 在 C++11 之后最大的一次语言变革，里面引入了大量具有革命性的新特性。罗能从一个独特的视角，讲解了其中最重要的四大特性。虽然 C++20 的新特性不止这四种，但编程并不是只讲特性：罗能的独特着眼点在于外面讨论较少的一些高级编程技巧，尤其是模板元编程方面。这比起干巴巴地讨论语言特性，明显要有用得多——毕竟，参考资料我们从 cppreference.com 之类的网站上自己就能找到，而高手的心得并不常有。</p>
<h3 id="袁英杰，软件架构咨询师，C- 资深专家">袁英杰，软件架构咨询师，C++ 资深专家</h3>
<p>C++ 发展到 2x，在继续坚守 C++ 的核⼼原则——你⽆需为你不需要的东⻄付出代价——的同时，已经演化为⼀⻔⾮常现代的语⾔，在保证运⾏时效率的同时，让你拥有更多的抽象⼿段，更加优雅地解决很多问题。为了更好地运⽤这⻔语⾔，你需要深刻理解每⼀个新特性的⽬的、机制和⽤法。罗能的这本《C++20⾼级编程》通过详尽⽽深⼊的解释，丰富的例⼦，会⼤⼤加速掌握这⻔令⼈兴奋的语⾔的进程。</p>
<h3 id="许胜军，华为 Camera 领域资深软件专家">许胜军，华为 Camera 领域资深软件专家</h3>
<p>这是一本能让人全面了解 C++20 特性以及高级模板编程的一本书。书中不仅对 C++ 语言新特性有着详细地描述，更难得的是对其这些特性的设计目的和方法也进行了描述。让人不再限于“会使用”，知其然且知其所以然。虽然这些语言特性，我所在的项目并没有全部都用过，作为同事，也曾和作者本人进行过交流，其关于这些特性的理解能引发我们对 C++ 编程更深入地思考。总之这是一本独特的精神粮食，值得推荐！</p>
<h3 id="孙孟越，清华大学，罡兴投资量化开发总监">孙孟越，清华大学，罡兴投资量化开发总监</h3>
<p>这本书是少有的中文 C++20 精品读物，作者从实践的角度出发，带领大家学习了高级模板编程、ranges 库、协程、modules 等 C++20 的重要内容。作者把自己的经验掰开揉碎了介绍给大家，这是每个 C++ 程序员提升自我水平的大好机会。</p>
<h2 id="为何编写本书？">为何编写本书？</h2>
<p>我从大学起便有写博客的习惯，这个习惯更多是梳理对技术知识的总结，倘若要寻找人生中的价值，那么记录我曾经存在过这个世界无疑是令人心动的。</p>
<p>我从 14 岁开始接触编程，像我这个年龄接触编程的大多数是起因于学校的 NOI 竞赛，通过他可以保送某些名校（直到大学才知道有这么一条途径），而我却是因为一台 Linux 学习机提供了编程的窗口，从此便一发不可收拾，差点连高中都没考上。</p>
<p>我接触的前两门语言分别是 Bash 和 C 语言，时常用它们写些（Vim 编辑器便是那时学会的，直到工作仍然是我唯一的选择）小工具玩，当我写的越多，我发现 C 语言越简陋，尤其是语言机制上的不足带来的抽象手段有限，程序员不得不使用大量的宏技巧来展开代码避免性能上的开销，以及到处都是细节的面向过程思想。</p>
<p>高中时我开始学习 C++ 语言，便被它所吸引，只可惜学习机那羸弱的性能编译一个简单的 hello world 程序都需要半分钟，我只好沉浸在 <em>C++ Primer Plus</em> 的世界里，尤其是面向对象的多态、虚函数机制非常迷人。</p>
<p>C++ 是自由的，它允许你在遵守规则的情况下做任何事，包括 shoot yourself in the foot，这就对 C++ 程序员要求相当高。语言是用来解决问题的工具，因而 C++ 演进过程中的大多特性都是基于问题与痛点出发的，如果程序员能理解这些特性背后的缘由，在遇到问题时便能使用合适的手段解决之。</p>
<p>直到大学时我才拥有第一台电脑，那时候便尝试写博客，鉴于国内主流博客平台需要审核文章，从此便选择了自建博客，然后同步到知乎平台。直到大学毕业工作的时候，写的多了便会有出版社编辑联系，经过某些原因，我在人民邮电出版社和机械工业出版社之间选择了后者。</p>
<p>在写博客的经历中，我也会时常看看其他大牛的博客、论文、CppCon 技术分享，主要和 C++ 相关，喜欢 C++ 并关注 C++ 的也主要是国外程序员，主要会看如下作者的：</p>
<ul>
<li>Jeff Preshing，加拿大程序员，主要涉及一些并发编程、语言特性相关话题</li>
<li>Bartosz Milewski，波兰程序员，理论物理学家，参与 D 语言设计与实现，主要涉及并发编程、模板元编程、范畴论相关话题</li>
<li>Andrzej，主要涉及 C++ 编程实践方面的知识，以及一些关于 C++ 设计和当前发展的理论背景，尤其是概念约束方面</li>
<li>Herb Sutter，C++ 标准委员会成员，介绍 C++ 的现代化进程、最佳实践</li>
<li>Eric Niebler，C++ 爱好者，ranges 标准库作者，主要涉及 C++ 技巧、函数式编程、协程、结构化并发等话题</li>
<li>Lewis Baker，主要介绍无栈协程理论、特性方面</li>
<li>Bjarne Stroustrup，C++ 之父，很多论文值得已读，即便他对 C++ 有很强烈想法，也未必能纳入标准，个人觉得他的代码风格很奇怪</li>
<li>吴咏炜，最初认识他是在他博客上看到关于 C++ 实现 Y combinator 的代码，非常有意思</li>
<li>袁英杰，我的启蒙恩师，对 C++ 以及软件设计理解、洞察力非常深，尤其是关于 C++ 技术层面的理解</li>
<li>还有很多优秀的程序员，不再一一枚举，待续</li>
</ul>
<p>在这期间正好编辑找上门来，问我能不能出一本 C++ 高级编程相关的书，以弥补国内出版社这方面话题的不足，国外同类书有 <em>Modern c++ design</em>, <em>C++ Templates: The Complete Guide</em> 等，要么年代比较久远，要么涉及语言细节过深，一下子便激发了我的写作热情：能否用更现代的 C++ 特性（尤其是 C++20）去解决那些问题？而且当时国内也没有 C++20 相关的书籍。</p>
<p>从 2021 年 2 月起开始，每天下班后写作，到 2022 年 2 月交稿，正好历时一年，交由出版社走流程花了 4 个月，最近已经开始预售了。有趣的是，正好和另一本国外引进的《C++20 高级编程》（原书名<em>Professional C++</em>）同名了，碰巧的是，我们都请到了吴咏炜作序。</p>
<p>写作部分，我很讨厌排版（尤其是 Word），更倾向于使用 Markdown/AsciiDoc 等标记语言排版，它们从设计上就让作者更关注内容而不是排版，但考虑 Markdown 等工具不能很好地给出当前写了多少页，加上排版效果比不上 LaTeX，因此整个过程中我选择了 LaTeX 进行写作。这就导致了最后交稿，出版社不支持 LaTeX 排版，而是从我出的 pdf 文件中重排，最终或多或少有细微影响如字体上的差异。</p>
<p>如果期待写书就能够获得很多收入是不现实的，目前技术书的销量相当确定，如果能达到三千本左右，便是畅销书了，而一本定价的 8% 即作为作者的收入，扣掉税后剩下来的就更少了，而投入的时间却相当大。因此如果你计划出书，那一定要考虑收入之外的因素。</p>
<h2 id="本书勘误">本书勘误</h2>
<p>此部分留给本书 <a href="https://netcan.github.io/2022/06/22/%E5%A6%82%E4%BD%95%E5%87%BA%E7%89%88%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E5%9B%BE%E4%B9%A6-%E5%86%99%E5%9C%A8%E3%80%8AC-20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%87%BA%E7%89%88%E4%B9%8B%E6%97%B6/#%E6%9C%AC%E4%B9%A6%E5%8B%98%E8%AF%AF"> 勘误</a>，由于笔者的水平有限，在写作过程中难免留有错误，恳请读者批评指正。</p>
<h2 id="参考资料">参考资料</h2>
<p>本书编写过程中参考过的资料（分章节）：</p>
<ul>
<li>
<p>类型与对象</p>
<ul>
<li>https://devblogs.microsoft.com/cppblog/how-to-use-class-template-argument-deduction/</li>
<li>https://herbsutter.com/elements-of-modern-c-style/</li>
<li>https://modern-cpp.readthedocs.io/zh_CN/latest/index.html</li>
<li>https://github.com/elbeno/using-types-effectively/blob/master/presentation.org</li>
</ul>
</li>
<li>
<p>编译时多态</p>
<ul>
<li>https://preshing.com/20210315/how-cpp-resolves-a-function-call/</li>
<li>https://accu.org/journals/overload/9/43/frogley_442/</li>
<li>https://www.internalpointers.com/post/quick-primer-type-traits-modern-cpp</li>
<li>http://www.eniscuola.net/en/2016/06/27/the-numbers-of-nature-the-fibonacci-sequence/</li>
<li>https://clang.llvm.org/docs/LanguageExtensions.html#type-trait-primitives</li>
<li>《从数学到泛型编程》</li>
<li>https://eli.thegreenplace.net/2014/sfinae-and-enable_if/</li>
<li>https://www.jianshu.com/p/38f17600f19a</li>
<li>https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F</li>
<li>https://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick</li>
<li>https://ledas.com/post/857-how-to-hack-c-with-templates-and-fri</li>
<li>https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/</li>
</ul>
</li>
<li>
<p>概念约束</p>
<ul>
<li>C++ Concepts - complete overview</li>
<li>The C++0x Concept Effort</li>
<li>Fundamentals of Generic Programming</li>
<li>The Design and Evolution of C++</li>
<li>Concept checking</li>
<li>Concepts – Design choices for template argument checking</li>
<li>Concepts for C++0x</li>
<li>A concept design (Rev. 1)</li>
<li>Concepts Lite: Constraining Templates with Predicates</li>
<li>Concepts: The Future of Generic Programming</li>
<li>https://akrzemi1.wordpress.com/2020/01/29/requires-expression/</li>
<li>https://akrzemi1.wordpress.com/2020/03/26/requires-clause/</li>
<li>https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/</li>
<li>https://stackoverflow.com/questions/62644070/differences-between-stdis-convertible-and-stdconvertible-to-in-practice</li>
</ul>
</li>
<li>
<p>元编程介绍</p>
</li>
<li>
<p>模板元编程</p>
<ul>
<li>https://ieeexplore.ieee.org/iel5/32/35910/01702623.pdf</li>
</ul>
</li>
<li>
<p>constexpr 元编程</p>
<ul>
<li>https://www.cppstories.com/2021/constexpr-vecstr-cpp20/</li>
<li>https://www.cppstories.com/2021/constexpr-new-cpp20/#limitations</li>
<li>Don’t constexpr All The Things</li>
<li>https://gist.github.com/Som1Lse/5309b114accc086d24b842fd803ba9d2</li>
<li>https://zh.wikipedia.org/wiki/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3</li>
</ul>
</li>
<li>
<p>ranges 标准库</p>
<ul>
<li>https://ericniebler.com/2018/12/05/standard-ranges/</li>
<li>https://www.nextptr.com/tutorial/ta1208652092/how-cplusplus-rangebased-for-loop-works</li>
<li>https://quuxplusone.github.io/blog/2020/07/11/the-std-swap-two-step/</li>
<li>http://mmore500.com/cse-491/blog/2020/04/20/ranges-transpose.html</li>
<li>https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3%E4%B9%98%E6%B3%95</li>
<li>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2387r0.html</li>
<li>https://github.com/ericniebler/range-v3</li>
</ul>
</li>
<li>
<p>无栈协程</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Cpp-Club/Cxx_HOPL4_zh">C++ HOPL</a></li>
<li>The history, present and future of computer language coroutines</li>
<li>https://en.wikipedia.org/wiki/Coroutine#C++</li>
<li>https://www.itproportal.com/features/the-rise-of-the-coroutines/</li>
<li>https://www.youtube.com/watch?v=_fu0gx-xseY</li>
<li>https://blog.panicsoftware.com/coroutines-introduction/</li>
<li>https://github.com/lewissbaker/lewissbaker.github.io/blob/master/_posts/2017-09-25-coroutine-theory.md</li>
<li>https://hacksoflife.blogspot.com/2021/06/c-coroutines-getting-past-names.html</li>
<li>Coroutine changes for C++20 and beyond</li>
</ul>
</li>
<li>
<p>模块</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Cpp-Club/Cxx_HOPL4_zh">C++ HOPL</a></li>
<li>https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-170</li>
<li>Practical C++ Modules</li>
<li>https://vector-of-bool.github.io/2019/03/10/modules-1.html</li>
<li>C++20 modules with GCC11</li>
<li>https://docs.microsoft.com/en-us/cpp/cpp/tutorial-named-modules-cpp?view=msvc-170#create-the-primary-module-interface-unit</li>
</ul>
</li>
<li>
<p>综合运用</p>
<ul>
<li>https://docs.python.org/3/library/asyncio.html</li>
</ul>
</li>
</ul>

    
  </div>

</article>


   
       <div class="original">
    <ul>
        <li>本文标题：如何出版一本技术图书 -- 写在《C++20 高级编程》出版之时</li>
        <li>本文字数：7.2k</li>
        <li>本文作者：Netcan</li>
        <li>发布时间：2022年06月22日 - 18时29分</li>
        <li>最后更新：2022年12月09日 - 19时02分</li>
        <li>原始链接：<a href="https://netcan.github.io/2022/06/22/%E5%A6%82%E4%BD%95%E5%87%BA%E7%89%88%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E5%9B%BE%E4%B9%A6-%E5%86%99%E5%9C%A8%E3%80%8AC-20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%87%BA%E7%89%88%E4%B9%8B%E6%97%B6/">https://netcan.github.io/2022/06/22/如何出版一本技术图书-写在《C-20高级编程》出版之时/</a></li>
        <li>版权声明：<i class="icon icon-cc"></i><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" rel="external nofollow noopener noreferrer" target="_blank">"署名-非商用-相同方式共享 3.0"</a>转载请保留原文链接及作者。</li>
    </ul>
</div>

   

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Netcan</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2022/05/16/%E5%A6%99%E7%94%A8-std-optional-%E7%B1%BB%E7%AE%80%E5%8C%96%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2022/12/09/C-%E7%BC%96%E8%AF%91%E6%97%B6%E8%B0%93%E8%AF%8D%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>
<script>
    $(".article-content img").wrap(function() {
        return '<a data-fancybox href="' + $(this).attr("src") + '"/>';
    });
</script>


  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '893a4103795fc66cd8e7',
  clientSecret: '35c92c3dca938831b67dc22e46d64bc9073ebacf',
  repo: 'netcan.github.io',
  owner: 'Netcan',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['Netcan'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
