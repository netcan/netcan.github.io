<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>《Effective Modern C++》第一章笔记：Deducing Types | Netcan on Programming</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C/C++," />
  

  <meta name="description" content="这几天人工智能成绩出来了，还是开卷考试，竟然挂掉了，真是意不意外。。。请导员查了一下平时分：卷面 46&#x2F;100，平时 53&#x2F;100，按经验来说，只要卷面过 40，靠平时分还是能拉到及格的，以前平时分一般会给到 90 左右，这次真是吃了平时分的亏了。 回忆了一下，人工智能这门课不点名，但是每节课都会有随堂测试，靠这个来算平时分吧。这门课我印象中缺过两节课，因为前段时间在忙比赛，加上开卷，期间也和老师">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective Modern C++》第一章笔记：Deducing Types">
<meta property="og:url" content="https://netcan.github.io/2017/05/12/%E3%80%8AEffective-Modern-C-%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0Deducing-Types/index.html">
<meta property="og:site_name" content="Netcan on Programming">
<meta property="og:description" content="这几天人工智能成绩出来了，还是开卷考试，竟然挂掉了，真是意不意外。。。请导员查了一下平时分：卷面 46&#x2F;100，平时 53&#x2F;100，按经验来说，只要卷面过 40，靠平时分还是能拉到及格的，以前平时分一般会给到 90 左右，这次真是吃了平时分的亏了。 回忆了一下，人工智能这门课不点名，但是每节课都会有随堂测试，靠这个来算平时分吧。这门课我印象中缺过两节课，因为前段时间在忙比赛，加上开卷，期间也和老师">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-05-12T01:25:59.000Z">
<meta property="article:modified_time" content="2022-12-09T11:02:08.585Z">
<meta property="article:author" content="Netcan">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/site.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-174901164-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d2c292719a76d8c0fa7f9874379cfd25";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Netcan on Programming" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">ROOT</span>
  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/>
<link rel="stylesheet" href="/css/prism.css">

<div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">ROOT</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-1-Understand-template-type-deduction"><span class="toc-text">Item 1: Understand template type deduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1-ParamType%20%E6%98%AF%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-text">Case 1: ParamType 是指针或者引用，但不是通用引用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-2-ParamType%20%E6%98%AF%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8"><span class="toc-text">Case 2: ParamType 是通用引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-3-ParamType%20%E6%97%A2%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8D%E6%98%AF%E6%8C%87%E9%92%88"><span class="toc-text">Case 3: ParamType 既不是引用也不是指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-text">数组作为参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-text">函数作为参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Things-to-Remember"><span class="toc-text">Things to Remember</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-2-Understand-auto-type-deduction"><span class="toc-text">Item 2: Understand auto type deduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Things-to-Remember-2"><span class="toc-text">Things to Remember</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-3-Understand-decltype"><span class="toc-text">Item 3: Understand decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Things-to-Remember-3"><span class="toc-text">Things to Remember</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-4-Know-how-to-view-deduced-types"><span class="toc-text">Item 4: Know how to view deduced types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDE%20%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-text">IDE 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%8A%E6%96%AD"><span class="toc-text">编译器诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%BE%93%E5%87%BA"><span class="toc-text">运行时输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Things-to-Remember-4"><span class="toc-text">Things to Remember</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-《Effective-Modern-C-》第一章Deducing-Types" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">《Effective Modern C++》第一章笔记：Deducing Types</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.05.12</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Netcan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>这几天人工智能成绩出来了，还是开卷考试，竟然挂掉了，真是意不意外。。。请导员查了一下平时分：卷面 46/100，平时 53/100，按经验来说，只要卷面过 40，靠平时分还是能拉到及格的，以前平时分一般会给到 90 左右，这次真是吃了平时分的亏了。</p>
<p>回忆了一下，人工智能这门课不点名，但是每节课都会有随堂测试，靠这个来算平时分吧。这门课我印象中缺过两节课，因为前段时间在忙比赛，加上开卷，期间也和老师提前打过招呼（邮件没回复，估计没看到），随堂测试靠度娘。结果居然因为平时分太低也救不了了。</p>
<p>最近买了本动物书《Effective Modern C++》，好评，从头到尾指出了一些 C++11/14 的坑，同时介绍一些技巧如何避免这些坑。</p>
<p>这里做一下笔记，备忘。我用的是 <code>clang</code> 编译器。</p>
<p>这章主要是介绍 C++11/14 的推导规则，以及各种坑。</p>
<h2 id="Item-1-Understand-template-type-deduction">Item 1: Understand template type deduction</h2>
<p>首先从模板类型推导开始，后面的 <code>auto</code> 关键字和模板类型推导规则差不多的。需要注意下面说的 <code>parameter</code> 就是形参，而 <code>argument</code> 是实参。</p>
<p>首先用如下伪代码介绍：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板函数</span>

<span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 f，argument 是 expr，根据 expr 来确定 T 和 param 的类型。</span></code></pre>
<p>其中 T 的类型不仅由 expr 来确定，还由 ParamType 来确定的。这里有 3 种情况：</p>
<ul>
<li>ParamType 是一个指针或者引用，但不是通用引用。（这里可以先理解为<code>T &amp;&amp;</code>。）</li>
<li>ParamType 是通用引用。</li>
<li>ParamType 既不是引用也不是指针</li>
</ul>
<h3 id="Case-1-ParamType 是指针或者引用，但不是通用引用。">Case 1: ParamType 是指针或者引用，但不是通用引用。</h3>
<p>规则如下：</p>
<ol>
<li>如果 expr 是引用，那就忽略其引用部分</li>
<li>根据 expr 的类型来匹配 ParamType 和 T</li>
</ol>
<h3 id="Case-2-ParamType 是通用引用">Case 2: ParamType 是通用引用</h3>
<p>规则如下：</p>
<ul>
<li>如果 expr 是左值，那么 T 和 ParamType 都被推导成左值引用</li>
<li>如果 expr 是右值，规则和 Case 1 一样。即忽略引用部分（&amp;&amp;），然后根据 expr 的类型来匹配 ParamType 和 T</li>
</ul>
<h3 id="Case-3-ParamType 既不是引用也不是指针">Case 3: ParamType 既不是引用也不是指针</h3>
<p>既然 ParamType 既不是引用也不是指针，那么用的就是传值方式了。</p>
<p>规则如下：</p>
<ol>
<li>如果 expr 是引用，那么忽略引用部分</li>
<li>忽略 expr 的引用部分后，如果带 <code>const/volatile</code> 修饰符，那么也忽略掉</li>
<li>最后根据 expr 的类型来匹配 ParamType 和 T</li>
</ol>
<p>举个例子：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板函数</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T 和 param 的类型为 int</span></code></pre>
<p>这里的 rx 虽然为 <code>const int &amp;</code> 类型，根据规则 1 和 2，忽略引用和 const，那么就变成了 <code>int</code> 类型。之所以要去掉 const，是因为 expr 不能被修改并不意味着其副本不能被修改。也就是说最后的 param 可以修改，因为修改它不会影响到 rx。</p>
<p>还有一种情况类似，需要注意。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token string">"hello Netcan"</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T 和 param 的类型为 const char *</span></code></pre>
<p>根据规则 2，去掉 const 限定符，那么变成的是 <code>const char*</code> 类型。可以看出去掉的是后面那个 const，因为 ptr 的值是 const，表明 ptr 不能被修改，传值的时候可以去掉；而前面那个 const 表面 ptr<strong>指向的内容 </strong> 不能被修改，限定的不是 ptr，需要保留的。</p>
<h3 id="数组作为参数">数组作为参数</h3>
<p>这种情况比较特殊，毕竟数组类型和指针不同，尽管有时候可以看成是同一个东西。之所以引起大多数人的疑惑，是因为在许多情况下，数组会退化 (decay) 成指针（指向它的第一个元素），这种退化才能允许如下代码通过：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Netcan"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> ptrToName <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 这种情况就是数组退化成指针了</span></code></pre>
<p>这里 <code>ptrToName</code> 是一个 <code>const char*</code> 指针，指向的是数组 name，而数组 name 的类型是 <code>const char[7]</code>，显然<code>const char*</code> 和<code>const char[7]</code>并不是同一个类型，但是因为数组的退化规则，导致代码能编译通过。</p>
<p>如果数组传给一个模板（Case 3），情况如何？</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T 被推导成 const char*/const char[]</span></code></pre>
<p>很显然，T 被推导成一个指针类型了，并不是真正的数组类型。但是如果声明成引用参数，如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板函数</span>
<span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这里 T 被推导成真正的数组类型了，也就是说，T 被推导成<code>const char[7]</code>，而 param 的类型为<code>const char(&amp;)[7]</code>。</p>
<p>根据这个技巧，可以写出如下模板函数，推导出数组的元素个数。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token operator">::</span>size_t N<span class="token operator">></span>
<span class="token keyword">constexpr</span> std<span class="token operator">::</span>size_t <span class="token function">arraySize</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 因为我们关心的是数组元素个数，所以参数名可以省略了</span>
	<span class="token keyword">return</span> N<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>constexpr 关键字表明在编译过程中就能确定出结果，noexcept 有助于编译器优化。</p>
<p>书上推荐用内置的 <code>std::array</code> 类型作为数组使用。</p>
<h3 id="函数作为参数">函数作为参数</h3>
<p>不仅仅是数组类型能退化成指针，函数类型也能退化成函数指针。这种情况和前面说的数组推导是一样的。这种情况在实践中用引用和指针没什么区别，不再概述，原理懂了就行。</p>
<h3 id="Things-to-Remember">Things to Remember</h3>
<ul>
<li>模板推导中，argument 的引用性可以忽略</li>
<li>当 param 是通用引用的时候，argument 为左值需要特别注意</li>
<li>当 param 是传值类型 (Case 3) 的时候，argument 的 const/volatile 需要忽略</li>
<li>模板推导中，argument 为数组或者函数的时候会退化成指针，除非 param 用引用</li>
</ul>
<h2 id="Item-2-Understand-auto-type-deduction">Item 2: Understand auto type deduction</h2>
<p>auto 类型推导和模板推导差不多，但有些地方不同。之前说的模板参数推导：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板函数</span>

<span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 f，argument 是 expr，根据 expr 来确定 T 和 param 的类型。</span></code></pre>
<p>当用 auto 来声明变量的时候，auto 相当于这里面的 T，而变量类型相当于 ParamType。所以也有三种情况：</p>
<ul>
<li>Case 1: 声明的类型是指针或者引用，但不是通用引用</li>
<li>Case 2: 声明的类型是是通用引用</li>
<li>Case 3: 声明的类型既不是引用也不是指针</li>
</ul>
<p>按照模板推导的方法来做就是了。</p>
<p>但是有一点不同，需要特别指出。</p>
<p>C++98 有两种初始化变量的方法：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>C++11 添加了 <strong> 通用 </strong> 初始化（就是花括号）变量的方法，如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x4<span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>后面 Item 5 会提到利用 auto 来代替直接指出变量类型的优点，所以将 int 用 auto 替代得到如下代码：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x4<span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>如上声明都能通过编译，但是有区别。前两条语句都是将 x 声明为 int 类型，而 <strong> 后两条 </strong> 语句声明的是 <code>std::initializer_list&lt;int&gt;</code> 类型，其包含了一个元素 27，这是一个巨大的陷阱，也是一些程序员只有在必须要用到花括号初始化的时候才用的原因。（需要注意的是，由于 C++ 标准委员会接受了提议 <code>N3922</code>，这个提议使得 x4 这种初始化不再为<code>std::initializer_list</code> 类型，而是 <code>int</code> 类型了。由于 <code>N3922</code> 不是 C++11 和 C++14 的部分，所以有些编译器实现了 <code>N3922</code>，比如说我用的<code>clang</code> 就是把 x4 推导为 <code>int</code> 类型。）</p>
<p>这就是 auto 类型推导需要 <strong> 特别注意 </strong> 的地方。当 auto 声明的变量初始化用花括号的时候，推导的类型为<code>std::initializer_list</code>。如果无法推导，那么报错。</p>
<p>而模板推导的时候，若传通用初始化，将会 <strong> 报错 </strong>，这点和 auto 不同，它不会推导成<code>std::initializer_list</code> 类型。</p>
<p>关于通用初始化，这两者表现出来的行为不同，作者也无法理解，就把它当做规则来记吧。</p>
<p>然而在 C++14 中，允许 auto 作为函数 <strong> 返回类型 </strong>，用来推导函数的返回类型，并且 C++14 也支持在 lambdas 中使用 auto 来声明<strong>param</strong>。这个时候 auto 使用的是<strong> 模板推导 </strong> 的规则，而不是 auto 的推导规则了。也就是说如下代码无法编译通过：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">createInitList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误！无法推导出 &#123;1, 2, 3&#125; 的类型</span>
<span class="token punctuation">&#125;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
<span class="token keyword">auto</span> resetV <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>v<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> v <span class="token operator">=</span> newValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">resetV</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误！理由同上</span></code></pre>
<h3 id="Things-to-Remember-2">Things to Remember</h3>
<ul>
<li>auto 类型推导通常和模板类型推导规则一样，但是 auto 类型推导将花括号初始化看做<code>std::initializer_list</code>，而模板类型推导不会</li>
<li>auto 用在函数返回值或者 lambdas 的 param 中，用的是模板推导的规则而不是 auto 类型推导规则。</li>
</ul>
<h2 id="Item-3-Understand-decltype">Item 3: Understand decltype</h2>
<p>decltype 关键字用来给出一个变量名或者表达式的 <strong> 真正 </strong> 类型。通常情况下使用没什么问题，这里不在举例。</p>
<p>在 C++11 中一个基本的用法就是用在声明函数的返回类型，而返回类型依赖于函数的 param 类型。</p>
<p>一般来说 <code>operator[]</code> 返回的通常是容器中元素的引用，即 <code>T&amp;</code>。也有例外，比如<code>std::vector&lt;bool&gt;</code> 返回的不是<code>bool&amp;</code>，而是一个新的临时对象，这点非常重要，在 Item 6 中会提到。</p>
<p>假如现在需要写一个函数，对用户进行权限检查，然后再索引容器中的元素，如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Index</span><span class="token operator">></span>
<span class="token operator">?</span>type<span class="token operator">?</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">autheticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>那么这个 <code>?type?</code> 应该是什么类型呢？无从判断，这时候 decltype 派上用场了：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Index</span><span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">autheticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>注意这里的 auto 并没别的作用，只是占位符罢了。而 param 表后面的 <code>-&gt;</code> 是 C++11 的 <em>trailing return type</em> 语法，因为 decltype 需要用到前面声明的 c 和 i。</p>
<p>在 C++14 中可以省略后置返回类型写法，比如前面提到的，只用 auto 来推导函数的返回类型，将使用模板推导的规则：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Index</span><span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">autheticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>细心的话，会发现这样写有严重的 bug，那就是 <strong> 丢失引用 </strong>。因为 c[i] 返回的是 <code>T&amp;</code> 类型，而函数用的是<code>auto</code>，根据模板推导规则的 Case 3，会导致函数返回的类型为<code>T</code>，变成了右值。</p>
<p>上面这个例子就是想说明，我们需要 decltype 这样的类型推导，因为它能返回 <strong> 精确 </strong> 的类型。</p>
<p>C++ 预料到了这种情况，在 C++14 中提出了 <code>decltype(auto)</code> 说明符，很好地解决了这个问题，因此可以改写成这样：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Index</span><span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">autheticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>这时候 <code>authAndAccess</code> 将会返回和 c[i]一样的类型了，比如 c[i]返回的是 <code>T&amp;</code>，那么<code>authAndAccess</code> 也是 <code>T&amp;</code>；c[i] 返回的是对象，那么 <code>authAndAccess</code> 也将返回对象。</p>
<p>同时也能用在初始化表达式中，如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>
<span class="token keyword">const</span> Widget <span class="token operator">&amp;</span>cw <span class="token operator">=</span> w<span class="token punctuation">;</span>
<span class="token keyword">auto</span> myWidget1 <span class="token operator">=</span> cw<span class="token punctuation">;</span> <span class="token comment">// myWidget1 的类型为 Widget</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> myWidget2 <span class="token operator">=</span> cw<span class="token punctuation">;</span> <span class="token comment">// myWidget2 的类型为 const Widget &amp;</span></code></pre>
<p><code>authAndAccess</code>还有一个问题，它的 argument 是一个左值引用，非 const，因为程序调用它可能需要修改检索到的值，这没什么问题。但是不能传一个右值 argument 给它，因为右值不能绑定到左值引用上。一个方案是重载<code>authAndAccess</code>，写一个左值和右值版本的，这样就需要维护两个版本了。因此可以用通用引用来实现，得出如下版本：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Index</span><span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">autheticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>decltype 也有例外情况，这里需要 <strong> 注意 </strong> 下。C++ 定义左值表达式 <code>(x)</code> 为一个左值，所以 <code>decltype((x))</code> 的类型将是一个左值引用。也就是说：</p>
<pre class="language-none"><code class="language-none">int x &#x3D; 2;
decltype((x)) y &#x3D; x; &#x2F;&#x2F; y 的类型为 int &amp;

decltype(auto) f1() &#123;
	int x &#x3D; 0;
	return x; &#x2F;&#x2F; 返回值为 int，因为 decltype(x)为 int
&#125;

decltype(auto) f2() &#123;
	int x &#x3D; 0;
	return (x); &#x2F;&#x2F; 返回值为 int&amp;，因为 decltype((x))为 int&amp;，返回一个局部变量的引用，非常危险
&#125;</code></pre>
<h3 id="Things-to-Remember-3">Things to Remember</h3>
<ul>
<li>decltype 大多数时候返回的类型和变量或者表达式的类型一致</li>
<li>左值表达式 (x) 返回的是它的引用类型</li>
<li>C++14 支持 decltype(auto)说明符，虽然含有 auto，实际上用的是 decltype 的规则。</li>
</ul>
<h2 id="Item-4-Know-how-to-view-deduced-types">Item 4: Know how to view deduced types</h2>
<p>这一节讲了如何查看 C++ 推导出来的类型。</p>
<h3 id="IDE 编辑器">IDE 编辑器</h3>
<p>这个方法比较简单，需要 IDE 支持（IDE 从编译器那里取得相关信息），比如将鼠标放到变量上，就会显示出该变量的类型了。</p>
<p>但是也有缺点，就是当涉及到比较复杂的类型，那么给出来的信息就没什么用了。</p>
<h3 id="编译器诊断">编译器诊断</h3>
<p>更好的办法是用编译器编译的时候给出类型信息，就是让编译器报错，从而给出相关信息。</p>
<p>所以可以这么做，声明一个未定义的模板：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span></code></pre>
<p>当定义一个 TD 对象的时候，由于 TD 未定义，所以会报错。比如我想知道 x 的类型，那么：</p>
<pre><code>TD&lt;decltype(x)&gt; xType;
</code></pre>
<p>编译得出如下信息：</p>
<pre><code>error: implicit instantiation of undefined template 'TD&lt;const int *&gt;'
    TD&lt;decltype(x)&gt; xType;
</code></pre>
<p>很容易看出，x 的类型为<code>const int *</code>。</p>
<h3 id="运行时输出">运行时输出</h3>
<p>如果想让程序运行过程中，给出类型信息，要怎么做呢？书上首先介绍了 <code>typeid</code> 操作符，<code>typeid</code>会返回一个 <code>std::type_info</code> 对象，它有一个成员函数<code>name</code>，可以返回类型的字符串形式(<code>const char*</code>)。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>
<p>输出的结果为 <code>PKi</code>，<code>PK</code> 表示 <code>const *</code>，<code>i</code> 表示 <code>int</code>。可以用<code>c++-filt</code> 这个工具来获得可读的信息：</p>
<pre class="language-none"><code class="language-none">$ .&#x2F;a.out | c++filt -t
  int const*</code></pre>
<p>但是 <code>typeid</code> 也有巨坑，这里给出一个比较复杂的例子：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">auto</span> vw <span class="token operator">=</span> vector<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ... 省略初始化的元素了</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vw<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>那么这个 T 和 param 的类型是什么呢？先来分析下，<code>vw</code>是 <code>const vector&lt;Widget&gt;</code> 类型，那么 <code>vw[0]</code> 就是 <code>const Widget &amp;</code> 类型，<code>&amp;vw[0]</code>是 <code>const Widget *</code> 类型。然后根据 param 匹配，很容易知道 param 的类型为 <code>const Widget * const &amp;</code> 了，从而得知 T 的类型为<code>const Widget *</code>。</p>
<p>那么看看 <code>typeid</code> 给出来的结果：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"T ="</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"param ="</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>编译运行：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ ./a.out <span class="token operator">|</span> c++-filt -t
  T <span class="token operator">=</span> Widget const*
  param <span class="token operator">=</span> Widget const*</code></pre>
<p>可以看出 T 的类型对的，而 param 的类型是错的！再说了 T 怎么可能和 param 同一个类型，这也说明了 <code>std::type_info::name</code> 给出来的信息不可靠，因为 <code>typeid</code> 是通过传值方式（即 Item 1 的 Case 3）来处理参数，将 param 的引用和 const 忽略后，从而变成<code>T param</code>，这也就是为啥 T 和 param 的类型一样了。</p>
<p>具体来说：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>
<p>如果想得到正确的信息，最后给出的解决方案是用<em>Boost.TypeIndex</em>。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;boost/type_index.hpp></span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>
	<span class="token keyword">using</span> boost<span class="token operator">::</span>typeindex<span class="token operator">::</span>type_id_with_cvr<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"T ="</span>
		<span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"param ="</span>
		<span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>得出如下结果：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> Widget <span class="token keyword">const</span><span class="token operator">*</span>
param <span class="token operator">=</span> Widget <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token operator">&amp;</span></code></pre>
<p>顾名思义，<code>with_cvr</code>就表示保留 <code>const/volatile</code> 和引用了。</p>
<h3 id="Things-to-Remember-4">Things to Remember</h3>
<ul>
<li>查看推导的类型可以通过 IDE，编译器错误信息，<em>Boost.TypeIndex</em>库来实现</li>
<li>最重要的是理解 C++ 的推导规则</li>
</ul>

    
  </div>

</article>


   
       <div class="original">
    <ul>
        <li>本文标题：《Effective Modern C++》第一章笔记：Deducing Types</li>
        <li>本文字数：4.1k</li>
        <li>本文作者：Netcan</li>
        <li>发布时间：2017年05月12日 - 09时25分</li>
        <li>最后更新：2022年12月09日 - 19时02分</li>
        <li>原始链接：<a href="https://netcan.github.io/2017/05/12/%E3%80%8AEffective-Modern-C-%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0Deducing-Types/">https://netcan.github.io/2017/05/12/《Effective-Modern-C-》第一章Deducing-Types/</a></li>
        <li>版权声明：<i class="icon icon-cc"></i><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" rel="external nofollow noopener noreferrer" target="_blank">"署名-非商用-相同方式共享 3.0"</a>转载请保留原文链接及作者。</li>
    </ul>
</div>

   

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Netcan</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/03/23/2017%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E5%8F%82%E8%B5%9B%E5%BF%83%E5%BE%97/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/05/14/%E3%80%8AEffective-Modern-C-%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0auto/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>
<script>
    $(".article-content img").wrap(function() {
        return '<a data-fancybox href="' + $(this).attr("src") + '"/>';
    });
</script>


  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '893a4103795fc66cd8e7',
  clientSecret: '35c92c3dca938831b67dc22e46d64bc9073ebacf',
  repo: 'netcan.github.io',
  owner: 'Netcan',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['Netcan'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
