<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>CSAPP 第三章总结：Machine-Level Representation of Programs | Netcan on Programming</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="操作系统," />
  

  <meta name="description" content="以下为自用笔记，具体可看Computer Systems A Programmer’s Perspective。 这章主要讲高级语言的汇编形式，如何通过汇编 &#x2F; 反汇编来分析一个程序。要想深入理解操作系统，必须从底层开始，那就是汇编了。 因为我的机器是 64 位的，可以通过参数 -m32 来编译 32 位的程序，这样结果可和书中的尽可能吻合。建议用 -O1 或者 -O0 参数来汇编，这样使得汇编代">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP 第三章总结：Machine-Level Representation of Programs">
<meta property="og:url" content="https://netcan.github.io/2017/01/31/CSAPP%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%80%BB%E7%BB%93%EF%BC%9AMachine-Level-Representation-of-Programs/index.html">
<meta property="og:site_name" content="Netcan on Programming">
<meta property="og:description" content="以下为自用笔记，具体可看Computer Systems A Programmer’s Perspective。 这章主要讲高级语言的汇编形式，如何通过汇编 &#x2F; 反汇编来分析一个程序。要想深入理解操作系统，必须从底层开始，那就是汇编了。 因为我的机器是 64 位的，可以通过参数 -m32 来编译 32 位的程序，这样结果可和书中的尽可能吻合。建议用 -O1 或者 -O0 参数来汇编，这样使得汇编代">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-01-31T06:33:08.000Z">
<meta property="article:modified_time" content="2022-12-09T11:02:08.582Z">
<meta property="article:author" content="Netcan">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/site.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-174901164-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d2c292719a76d8c0fa7f9874379cfd25";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Netcan on Programming" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">ROOT</span>
  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/>
<link rel="stylesheet" href="/css/prism.css">

<div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">ROOT</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Program-Encodings"><span class="toc-text">Program Encodings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Formats"><span class="toc-text">Data Formats</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accessing-Information"><span class="toc-text">Accessing Information</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Operand-Specifiers"><span class="toc-text">Operand Specifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Movement-Instructions"><span class="toc-text">Data Movement Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arithmetic-and-Logical-Operations"><span class="toc-text">Arithmetic and Logical Operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Control"><span class="toc-text">Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition-Codes"><span class="toc-text">Condition Codes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jump-Instructions-and-Their-Encodings"><span class="toc-text">Jump Instructions and Their Encodings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Translating-Conditional-Branches"><span class="toc-text">Translating Conditional Branches</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loops"><span class="toc-text">Loops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Do-While-Loops"><span class="toc-text">Do-While Loops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#While-Loops"><span class="toc-text">While Loops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#For-Loops"><span class="toc-text">For Loops</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conditional-Move-Instructions"><span class="toc-text">Conditional Move Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch-Statements"><span class="toc-text">Switch Statements</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Procedures"><span class="toc-text">Procedures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transferring-Control"><span class="toc-text">Transferring Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Register-Usage-Conventions"><span class="toc-text">Register Usage Conventions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Procedure-Example"><span class="toc-text">Procedure Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursive-Procedures"><span class="toc-text">Recursive Procedures</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-Allocation-and-Access"><span class="toc-text">Array Allocation and Access</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-Arithmetic"><span class="toc-text">Pointer Arithmetic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nested-Arrays"><span class="toc-text">Nested Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fixed-Size-Arrays"><span class="toc-text">Fixed-Size Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variable-Size-Arrays"><span class="toc-text">Variable-Size Arrays</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heterogeneous-Data-Structures"><span class="toc-text">Heterogeneous Data Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Structures"><span class="toc-text">Structures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unions"><span class="toc-text">Unions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Alignment"><span class="toc-text">Data Alignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Putting-It-Together-Understanding-Pointers"><span class="toc-text">Putting It Together: Understanding Pointers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Life-in-the-Real-World-Using-the-gdb-Debugger"><span class="toc-text">Life in the Real World: Using the gdb Debugger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Out-of-Bounds-Memory-References-and-Buffer-Overflow"><span class="toc-text">Out-of-Bounds Memory References and Buffer Overflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thwarting-Buffer-Overflow-Attacks"><span class="toc-text">Thwarting Buffer Overflow Attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-Randomization"><span class="toc-text">Stack Randomization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-Corruption-Detection"><span class="toc-text">Stack Corruption Detection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Limiting-Executable-Code-Regions"><span class="toc-text">Limiting Executable Code Regions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86-64-Extending-IA32-to-64-Bits"><span class="toc-text">x86-64: Extending IA32 to 64 Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Machine-Level-Representations-of-Floating-Point-Programs"><span class="toc-text">Machine-Level Representations of Floating-Point Programs</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-CSAPP第三章总结：Machine-Level-Representation-of-Programs" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">CSAPP 第三章总结：Machine-Level Representation of Programs</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.01.31</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Netcan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>以下为自用笔记，具体可看<a target="_blank" rel="noopener" href="https://doc.lagout.org/programmation/Computer%20Systems%20-%20A%20Programmers%20Perspective.pdf">Computer Systems A Programmer’s Perspective</a>。</p>
<p>这章主要讲高级语言的汇编形式，如何通过汇编 / 反汇编来分析一个程序。要想深入理解操作系统，必须从底层开始，那就是汇编了。</p>
<p>因为我的机器是 64 位的，可以通过参数 <code>-m32</code> 来编译 32 位的程序，这样结果可和书中的尽可能吻合。建议用 <code>-O1</code> 或者 <code>-O0</code> 参数来汇编，这样使得汇编代码与源代码差别不是很大。</p>
<h2 id="Program-Encodings">Program Encodings</h2>
<p>这里的汇编格式为 <code>ATT</code>，而不是学校教的<code>Intel</code> 格式，最大区别就是指令目标操作数和源操作数相反，还有 <code>ATT</code> 汇编的同一条指令有 <strong> 好几条 </strong> 形式，对应于不同操作数数据类型的 <strong> 长度</strong>，后面会说。</p>
<p>汇编<code>code.c</code>：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ gcc -O1 -S -m32 code.c
	.file	<span class="token string">"code.c"</span>
	.globl	accum
	.bss
	.align <span class="token number">4</span>
	.type	accum, @object
	.size	accum, <span class="token number">4</span>
accum:
	.zero	<span class="token number">4</span>
	.text
	.globl	<span class="token function">sum</span>
	.type	sum, @function
<span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre>
<p>以 <code>.</code> 开头的标签主要是给汇编器、链接器使用的。</p>
<p>反汇编：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ gcc -O1 -c -m32 code.c
$ objdump -d code.o
code.o:     <span class="token function">file</span> <span class="token function">format</span> elf32-i386
Disassembly of section .text:
00000000 <span class="token operator">&lt;</span>sum<span class="token operator">&gt;</span>:
   <span class="token number">0</span>:	<span class="token number">55</span>                   	push   %ebp
   <span class="token number">1</span>:	<span class="token number">89</span> e5                	mov    %esp,%ebp
   <span class="token number">3</span>:	<span class="token number">83</span> ec <span class="token number">10</span>             	sub    <span class="token variable">$0x10</span>,%esp
   <span class="token number">6</span>:	e8 fc ff ff ff       	call   <span class="token number">7</span> <span class="token operator">&lt;</span>sum+0x<span class="token operator"><span class="token file-descriptor important">7</span>&gt;</span>
   b:	05 01 00 00 00       	<span class="token function">add</span>    <span class="token variable">$0x1</span>,%eax
  <span class="token number">10</span>:	8b 4d 08             	mov    0x8<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>,%ecx
  <span class="token number">13</span>:	8b <span class="token number">55</span> 0c             	mov    0xc<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>,%edx
  <span class="token number">16</span>:	01 ca                	<span class="token function">add</span>    %ecx,%edx
  <span class="token number">18</span>:	<span class="token number">89</span> <span class="token number">55</span> fc             	mov    %edx,-0x4<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>
  1b:	8b <span class="token number">88</span> 00 00 00 00    	mov    0x0<span class="token punctuation">(</span>%eax<span class="token punctuation">)</span>,%ecx
  <span class="token number">21</span>:	8b <span class="token number">55</span> fc             	mov    -0x4<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>,%edx
  <span class="token number">24</span>:	01 ca                	<span class="token function">add</span>    %ecx,%edx
  <span class="token number">26</span>:	<span class="token number">89</span> <span class="token number">90</span> 00 00 00 00    	mov    %edx,0x0<span class="token punctuation">(</span>%eax<span class="token punctuation">)</span>
  2c:	8b <span class="token number">45</span> fc             	mov    -0x4<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>,%eax
  2f:	c9                   	leave
  <span class="token number">30</span>:	c3                   	ret</code></pre>
<p>第一列为指令 <strong> 地址 </strong>，第二列为指令的<strong> 二进制编码 </strong> 形式，第三列为指令的 <strong> 汇编 </strong> 形式。</p>
<p>需要注意的是，链接的时候链接器会移动指令地址，还有由于 <code>Intel</code> 系列的是<code>little-endian</code>，高地址存放数据高位，低地址存放数据低位。</p>
<ul>
<li><code>%eip</code>寄存器为 <code>PC</code> 计数器，指向 <strong> 下一条 </strong> 要执行指令的地址。</li>
<li>32 位汇编有 8 个整数寄存器，可以存放指针、数值、临时变量、局部变量、返回值（一般存到 <code>%eax</code> 作为程序返回值）</li>
<li><code>condition code</code>寄存器存放最近运算的状态，主要用来实现一些算逻运算、条件转移、流程控制等等，比如<code>if</code>，<code>while</code></li>
<li>有浮点寄存器专门存放浮点数</li>
</ul>
<h2 id="Data-Formats">Data Formats</h2>
<p>167 页给出了数据格式。</p>
<p>最常用的就是 <code>b</code> 表示 1 字节。<code>w</code>表示双字节，因为早期 <code>Intel</code> 使用 <code>word</code> 来表示 <strong>16 位</strong> 数据类型，由于历史遗留，就这么表示了。<code>l</code>表示 4(<code>long word</code>)字节（8 字节的 <code>double</code> 也用 <code>l</code> 表示）。<code>q</code>表示 64 位(<code>quad word</code>)，32 位机器用连续 2 块来实现。</p>
<h2 id="Accessing-Information">Accessing Information</h2>
<p>168 页图 3.2 给出了 8 个寄存器。分别为<code>%eax</code>, <code>%ecx</code>, <code>%edx</code>, <code>%ebx</code>, <code>%esi</code>, <code>%edi</code>, <code>%esp</code>, <code>%ebp</code>。</p>
<p>每个寄存器都可以访问其低 <code>16</code> 位内容，例如 <code>%eax</code> 的<code>%ax</code>表示其低 16 位内容，这么做主要是 <code>Intel</code> 考虑向后兼容（兼容 16 位程序），而前四个寄存器可以访问到 2 个低 8 位内容，也是考虑向后兼容（backward compatibility）。</p>
<p>前 6 个寄存器为通用寄存器，大多数时候可以任意访问，其中前 3 个为 <code>caller-save</code> 寄存器，亦即函数调用的时候可随意使用，而后 3 个为 <code>callee-save</code> 寄存器，意味着函数调用的时候被调函数需要保存 / 恢复其值才能使用。</p>
<p>后 2 个寄存器，<code>%esp</code>为栈指针寄存器，<code>%ebp</code>为帧指针寄存器。</p>
<h3 id="Operand-Specifiers">Operand Specifiers</h3>
<p>169 页图 3.3 给出了一些操作数形式。</p>
<ul>
<li>立即数，例如 $123 表示 123 这个数。</li>
<li>寄存器的值，例如<code>%eax</code>。</li>
<li>内存访问 Imm(Eb, Ei, s)，例如 9(%eax,%edx, 4)，表示内存 <strong> 地址</strong> M[%eax + 4*%edx +9] 的值。</li>
</ul>
<h3 id="Data-Movement-Instructions">Data Movement Instructions</h3>
<p>171 页表 3.4 给出数据移动指令。</p>
<ul>
<li>MOV 指令，有几种形式，例如 <code>movl</code>, <code>movb</code>, <code>movw</code>，其后缀<code>l</code>, <code>b</code>, <code>w</code> 指定了操作数的长度。</li>
<li>MOVS/MOVZ 指令，符号扩展 / 零扩展，主要是当操作数长度不一致的时候使用。例如源操作数只有 2 字节，而目标操作数有 4 字节，short(S) -&gt; int(D)，因为有符号，就<code>movswl S, D</code></li>
<li>pushl S 指令，将 S 操作数存放到栈中。需要注意的是，栈指针 <code>%esp</code>（栈顶）存放的是<strong> 当前 </strong> 入栈的操作数。栈往低地址分配栈空间。</li>
<li>popl D 指令，将栈顶元素弹出，存放到 <code>D</code> 中。需要注意的是，出栈亦即回收空间，栈指针向高地址移动。</li>
</ul>
<p>这里有个重点，就是指令的目标操作数和源操作数，<strong>最多 </strong> 只能有一个内存访问，例如 <code>movl (%eax), (%edx)</code> 是不允许的。这个我们操作系统田老师解释过了，如果 2 个操作数都是内存取值，那么效率大大减低，涉及多次内存访问，这是很费时的。如要实现上述效果，可以拆成 2 条：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">movl (%eax), %ecx
movl %ecx, (%edx)</code></pre>
<h2 id="Arithmetic-and-Logical-Operations">Arithmetic and Logical Operations</h2>
<p>178 页表 3.7 给出了一系列算逻操作。</p>
<p><code>leal S,D</code>指令，这个比较重要，和 <code>mov</code> 指令类似，主要是用于指针运算。举个例子，<code>movl 9(%eax,%edx, 4), %eax</code>，这个是把内存 <strong> 地址 </strong> M[%eax + 4*%edx +9] 的值存放到 %eax 寄存器；而<code>leal 9(%eax,%edx, 4), %eax</code>，这个则是把<code>%eax + 4*%edx +9</code> 的结果存放到寄存器<code>%eax</code>。显然，前一个是引用内存的值，后一个是指针运算。</p>
<p>位移运算，有算数位移和逻辑位移 2 种，左移右移 2 种，一共 4 种指令。算数左移和逻辑左移的效果是一样的，右边填充 0。而逻辑右移，左边填充 0；算数右移，左边填充符号位。位移限制范围在 0 到 31，所以只考虑操作数低 5 位（亦即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="11.221ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 4959.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(500, 363) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g><g data-mml-node="mo" transform="translate(1125.8, 0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2126, 0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2903.8, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3959.6, 0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500, 0)"></path></g></g></g></svg></mjx-container>）</p>
<p>关于乘除运算。有乘除运算 2 种，各自又有符号 / 无符号运算 2 种，一共 4 种指令。然而 2 个 32 位数相乘可能溢出（64 位），这里的乘法指令会将高 32 位存放到 <code>%edx</code> 寄存器，低 32 位存放到 <code>%eax</code> 寄存器；除法 <code>%edx</code> 存放模，<code>%eax</code>存放商。</p>
<p>其他算逻运算可看表，没什么好说的了，同理，每个指令也有好几条形式，对应不同的操作数，例如加法指令<code>add</code>，就有<code>addl</code>, <code>addw</code>，等等。</p>
<p>对了通常用 <code>xor</code> 指令来置零，因为它生成的机器码比 <code>mov</code> 要短。</p>
<h2 id="Control">Control</h2>
<h3 id="Condition-Codes">Condition Codes</h3>
<p>前面提到，<code>Condition Codes</code>单位寄存器会存放最近算逻运算相关信息，最常用的有以下几个：</p>
<ul>
<li>CF，主要用来反映运算是否产生进位或借位。可以用来检测 <strong> 无符号 </strong> 操作是否溢出。如果运算结果的最高位产生了一个进位或借位，那么，其值为 1，否则其值为 0。</li>
<li>ZF，运算结果是否为 0。如果运算结果为 0，则其值为 1，否则其值为 0。</li>
<li>SF，用来反映运算结果的符号位，它与运算结果的最高位相同。运算结果为正数时，SF 的值为 0，否则其值为 1。</li>
<li>OF，用于反映 <strong> 补码 </strong> 运算结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF 的值被置为 1，否则，OF 的值被清为 0。</li>
</ul>
<p>根据一系列<code>Condition Codes</code>，可以实现条件判断。</p>
<p>举个例子。设 <code>t=a+b</code>，那么上面几个<code>Condition Codes</code> 将会设置如下：</p>
<pre><code>CF = (unsigned)t &lt; (unsigned)a
ZF = (t==0)
SF = (t&lt;0)
OF = (a &lt; 0 == b &lt; 0) &amp;&amp; (t&lt;0 != a&lt;0)
</code></pre>
<p>这里也可以看出 <code>CF</code> 和<code>OF</code>的区别，<code>CF</code>把操作数当 <strong> 无符号 </strong> 数来看待；而<code>OF</code>，判断 2 个同号的数运算结果是否异号，即溢出（正 + 正 = 负，负 + 负 = 正）。</p>
<p>186 页表 3.10 给出了相关判断指令，例如 <code>cmp</code> 和<code>test</code>指令。表 3.11 给出了 <code>set</code> 指令。
<code>cmp S,D</code>，根据 D-S 的差，设置 <code>Condition Codes</code>。各大编程语言的<code>cmp</code> 比较函数也应该衍生于此吧。</p>
<p><code>test S,D</code>，根据 S&amp;D（按位且）的结果，设置 <code>Condition Codes</code>。典型应用就是，<code>testl %eax, %eax</code>，用来判断<code>%eax</code> 的正负、或者是否为 0。</p>
<p><code>set D</code>，一系列 <code>set</code> 指令，根据 <code>Condition Codes</code> 的混合操作来设置 <code>D</code>。例如<code>sete</code>，当运算结果为 0，设置 D 为 1，这个表 3.11 说的很清楚了。因为不能直接访问<code>Condition Codes</code>，所以可以根据<code>set</code> 指令来间接访问！需要注意的是，这类指令的操作数对象长度为 1 字节，所以 <code>setl</code> 指的是 <code>set less</code>，而不是<code>long word</code>。还有些<code>set</code> 指令会有多个名字，汇编器 / 反汇编器随便选一个名字。</p>
<h3 id="Jump-Instructions-and-Their-Encodings">Jump Instructions and Their Encodings</h3>
<p>190 页表 3.12 给出了一些列跳转指令。</p>
<p>其中 <code>jmp</code> 无条件跳转，操作数可以是直接跳转（标签），或者间接跳转（加个 * 号）</p>
<p>例如 <code>jmp *%eax</code> 跳转到 <code>%eax</code> 所指的地址，而 <code>jmp *(%eax)</code> 根据 <code>%eax</code> 所指的 <strong> 内存 </strong> 地址的值作为跳转地址。</p>
<p>其他 <code>jmp</code> 指令将根据条件进行跳转，例如 <code>je D</code>，当结果等于零（即 ZF=0）的时候，跳转到<code>D</code> 所指的标签。</p>
<p>虽然汇编跳转到的是 <strong> 标签 </strong>，而链接之后，将会对标签进行<strong> 编码</strong>。最常用的编码方式是 PC relative 的，即将目标指令的地址与当前指令的地址的差作为偏移量，这种编码通常用 1、2、4 字节，这样做的好处就是移到其他内存部分不需要修改相对地址。另一种常用的编码方式是绝对地址，用 4 字节存储目标的绝对地址。</p>
<h3 id="Translating-Conditional-Branches">Translating Conditional Branches</h3>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
	then<span class="token operator">-</span>statement
<span class="token keyword">else</span>
	<span class="token keyword">else</span><span class="token operator">-</span>statement</code></pre>
<p>一般翻译（<code>goto</code>相当于<code>jmp</code>）成：</p>
<pre class="language-none"><code class="language-none">	t = test-expr;
	if (!t)
		goto false;
	then-statement
	goto done;
false:
	else-statement
done:</code></pre>
<p>为什么翻译成这样呢？因为 <code>if</code> 语句可能没 <code>else</code> 而一定有<code>then</code>，上面这种形式是最简洁的。</p>
<p>书上有例子，可以看看。</p>
<h3 id="Loops">Loops</h3>
<p>C 语言循环有 <code>do-while</code>, <code>while</code>, <code>for</code> 三种，但是翻译的时候基本都是翻译成 <code>do-while</code> 形式。</p>
<h4 id="Do-While-Loops">Do-While Loops</h4>
<p><code>do-while</code>循环至少执行循环体一次。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span>
	body<span class="token operator">-</span>statement
	<span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>翻译如下：</p>
<pre class="language-c" data-language="c"><code class="language-c">loop<span class="token operator">:</span>
	body<span class="token operator">-</span>statement
	t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> loop<span class="token punctuation">;</span></code></pre>
<h4 id="While-Loops">While Loops</h4>
<p><code>while</code>循环根据条件来判断是否循环。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
	body<span class="token operator">-</span>statement</code></pre>
<p>翻译的时候，转化成 <code>do-while</code> 形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> done<span class="token punctuation">;</span>
	<span class="token keyword">do</span>
		body<span class="token operator">-</span>statement
	<span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
done<span class="token operator">:</span></code></pre>
<p>最终形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">	t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> done<span class="token punctuation">;</span>
loop<span class="token operator">:</span>
	body<span class="token operator">-</span>statement
	t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
done<span class="token operator">:</span></code></pre>
<h4 id="For-Loops">For Loops</h4>
<p><code>for</code>循环如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>init<span class="token operator">-</span>expr<span class="token punctuation">;</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span> update<span class="token operator">-</span>expr<span class="token punctuation">)</span>
	body<span class="token operator">-</span>statement</code></pre>
<p>也是翻译成 <code>do-while</code> 形式，首先转换成 <code>while</code> 形式，接着改成 <code>do-while</code> 形式就是了：</p>
<p><code>while</code>形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">init<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	body<span class="token operator">-</span>statement
	update<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><code>do-while</code>形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">init<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
	<span class="token keyword">goto</span> done<span class="token punctuation">;</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
	body<span class="token operator">-</span>statement
	update<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
done<span class="token operator">:</span></code></pre>
<p>最终形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">	init<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> done<span class="token punctuation">;</span>
loop<span class="token operator">:</span>
	body<span class="token operator">-</span>statement
	update<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
done<span class="token operator">:</span></code></pre>
<h3 id="Conditional-Move-Instructions">Conditional Move Instructions</h3>
<p>汇编有一种叫做 <code>Conditional Move</code> 指令，亦即 <code>cmov</code> 指令，用于高效实现三目表达式，对于现代处理器来说非常高效。</p>
<p>书上 210 页表 3.17 给出了一系列 <code>cmov</code> 指令。</p>
<p>早在 95 年的时候，就出现了 <code>cmov</code> 指令，根据条件来判断是否复制源操作数到目标操作数。但是这些年来这条指令几乎不使用，因为它不向后兼容，尽管 97 年的时候所有 x86 处理器都支持这条指令了。因为我的机器是 64 位，编译的时候默认还是会使用的，毕竟可以提高处理器流水线性能。而在 32 位机器，如果要使用这条指令的话，需要加上编译参数 <code>-march=i686</code> 才行。</p>
<p>举个例子</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">cmpl %edx, %ecx
cmovl %ebx, %eax</code></pre>
<p>上面这 2 条指令，主要就是判断 <code>%ecx</code> 的值是否小于 <code>%edx</code>，小于的话，把<code>%ebx</code> 寄存器的值拷贝到 <code>%eax</code> 中。同理 <code>cmovl</code> 的后缀并不代表操作数大小 <code>long word</code>，而是<code>less than</code> 的意思。</p>
<p>之所以 <code>cmov</code> 效率比 <code>conditional jump</code>(<code>if-else</code> 跳转)效率高，是因为处理器需要预判是否需要 <code>jmp</code>，而<code>cmov</code> 不需要预判，大大提高了处理器性能。</p>
<p>举个例子，如下代码</p>
<pre class="language-c" data-language="c"><code class="language-c">v <span class="token operator">=</span> test<span class="token operator">-</span>expr <span class="token operator">?</span> then<span class="token operator">-</span>expr <span class="token operator">:</span> <span class="token keyword">else</span><span class="token operator">-</span>expr<span class="token punctuation">;</span></code></pre>
<p>翻译成 <code>conditional jump</code> 形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> false<span class="token punctuation">;</span>
		v <span class="token operator">=</span> true<span class="token operator">-</span>expr<span class="token punctuation">;</span>
		<span class="token keyword">goto</span> done<span class="token punctuation">;</span>
false<span class="token operator">:</span>
	v <span class="token operator">=</span> <span class="token keyword">else</span><span class="token operator">-</span>expr<span class="token punctuation">;</span>
done<span class="token operator">:</span></code></pre>
<p>翻译成 <code>cmov</code> 形式：</p>
<pre class="language-c" data-language="c"><code class="language-c">vt <span class="token operator">=</span> then<span class="token operator">-</span>expr<span class="token punctuation">;</span>
v <span class="token operator">=</span> <span class="token keyword">else</span><span class="token operator">-</span>expr<span class="token punctuation">;</span>
t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> v <span class="token operator">=</span> vt<span class="token punctuation">;</span></code></pre>
<p>仔细对比可发现，<code>cmov</code>同时计算了 <code>then-expr</code> 和<code>else-expr</code>，然后判断取哪个值。而 <code>conditional jump</code> 需要预判计算 <code>then-expr</code> 还是<code>else-expr</code>。</p>
<p>当然也不是所有的条件表达式都可以使用<code>cmov</code>，有条件的。举例如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cread</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>xp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>xp <span class="token operator">?</span> <span class="token operator">*</span>xp <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>翻译成 <code>cmov</code> 的时候，因为同时计算了 <code>*xp</code> 和<code>0</code>，若 <code>xp==NULL</code> 的时候，<code>*xp</code>是没有意义的，会出现 null pointer dereferencing error。</p>
<h3 id="Switch-Statements">Switch Statements</h3>
<p><code>switch</code>翻译除了用 <code>if-else-if</code> 形式，更高效还有 <code>jmup table</code>，<code>jump table</code> 是一个数组，存放了一些跳转地址，根据计算条件值作为索引（下标），来进行跳转到相应部分。</p>
<p>书上 214 页给出了一个 <code>jump table</code> 的例子。C 语言的标签地址，可以用 <code>&amp;&amp;</code> 来获得，例如 <code>&amp;&amp;label</code> 表示 <code>label</code> 的地址，跳转到 <code>label</code> 可以这么写：<code>goto *&amp;&amp;label</code>。</p>
<p><code>jump table</code>虽然高效，但是也是有条件的，当条件的取值 <strong> 范围 </strong> 很小（为数不多），取值 <strong> 间隔 </strong> 较小，才会考虑使用<code>jump table</code>，毕竟开销比较大。</p>
<h2 id="Procedures">Procedures</h2>
<p>IA32 位函数调用是通过栈帧来实现的，通过栈来传递参数、存储 / 还原寄存器的值、保存局部变量。分配给一个函数调用的栈空间叫栈帧，其中 <code>%ebp</code> 作为帧指针，指向函数调用的 <strong> 开始 </strong>（其值保存的是调用它的函数的<code>%ebp</code> 的值，当函数返回的时候使得 <code>%ebp</code> 能正确恢复到调用它的函数的 <strong> 开始 </strong>）；<code>%esp</code> 作为栈指针，指向函数调用的末尾（220 页图 3.21 给出了栈帧空间结构）。注意栈往低地址分配空间，往高地址回收空间，所以当栈指针自减一个数表示分配空间，自加一个数表示回收空间。</p>
<h3 id="Transferring-Control">Transferring Control</h3>
<p>221 页给出了 3 个指令：<code>call</code>,<code>leave</code>,<code>ret</code>。</p>
<p><code>call</code>的操作数和 <code>jmp</code> 类似，接受一个标签（直接调用）或者地址（用 * 号表示，间接调用）作为调用目标。<code>call</code>一旦执行，会把下一条指令的 <strong> 地址 </strong><code>pushl</code> 到栈中，然后跳转到被调函数的开始地址，当被调函数返回的时候就能返回到这个地址。222 页图 3.22 给出了这个过程。</p>
<p>而 <code>ret</code> 指令，将会 <code>popl</code><strong> 返回地址 </strong>，接着跳转到这个地址，亦即返回到调用它的地址继续执行下去。所以正确的用法是，使得栈指针指向<strong> 返回地址 </strong>（通过多次<code>popl</code> 或者使用 <code>leave</code>），然后调用<code>ret</code> 返回。寄存器 **<code>%eax</code>** 通常作为返回值（指针、int）。</p>
<p>而 <code>leave</code> 指令，将栈指针 <code>%esp</code> 指向帧指针 <code>%ebp</code>，然后将<code>%ebp</code> 还原。</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">movl %ebp, %esp		Set stack pointer to beginning of frame
popl %ebp			Restore saved %ebp and set stack ptr to end of caller’s frame</code></pre>
<h3 id="Register-Usage-Conventions">Register Usage Conventions</h3>
<p>由于寄存器存储局部变量、中间变量等等，函数调用过程中，难免被调函数也需要使用寄存器，那么有可能会把主掉函数的寄存器抹掉，这时候就会出现冲突，所以需要一系列约定来约束寄存器的使用。</p>
<p>前面提到了，<code>%eax</code>,<code>%edx</code>,<code>%ecx</code>作为 <code>caller-save</code> 寄存器，是可以随意使用的；而 <code>%ebx</code>,<code>%esi</code>,<code>%edi</code> 作为 <code>callee-save</code> 寄存器，被调函数需要保存（保存到栈上）这些值才能使用，返回的时候需要还原。</p>
<h3 id="Procedure-Example">Procedure Example</h3>
<p>224 页给出了程序调用的例子，可以看看，深入理解函数调用的细节。</p>
<p>简而言之，函数首先保存帧指针 <code>%ebp</code> 的值到栈上，然后使得帧指针 <code>%ebp</code> 指向函数的开始处。接着栈指针 <code>%esp</code> 向低地址分配空间，存储局部变量、中间变量等等。当要调用函数的时候，将函数参数存储到 <strong> 栈</strong>上，然后调用函数。被调函数保存主调函数的 <code>%ebp</code> 指针，调整 <code>%ebp</code> 指针到被调函数开始处，若要使用参数，可以通过 <code>%ebp</code> 指针 <code>+4*i</code> 来获得（高地址已分配内容），被调函数可以通过多次 <code>popl</code> 或者 <code>leave</code>，恢复<code>%ebp</code> 的值，使得 <code>%esp</code> 栈指针指向 <strong> 返回地址 </strong>，<code>ret</code> 返回。</p>
<p>所以说被调函数返回一个局部结构体指针，局部数组将无效，就是因为主调函数可能将会分配栈空间而把这些内容给覆盖掉了。</p>
<p>一个函数调用通常为其分配 16 的整数倍空间，所以可能会有些栈空间浪费了，这么做也是考虑到数据对齐。</p>
<h3 id="Recursive-Procedures">Recursive Procedures</h3>
<p>229 页给出了递归调用的例子，和函数调用大同小异，可以看看。</p>
<h2 id="Array-Allocation-and-Access">Array Allocation and Access</h2>
<p>C 语言数组翻译为汇编代码比较直接，毕竟数组名也代表了数组的首地址，而数组又是连续分配的空间。</p>
<p>声明定义一个数组，</p>
<pre class="language-c" data-language="c"><code class="language-c">T A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>将会在内存中连续分配 <code>L*N</code> 字节空间，这里的 <code>L</code> 代表 <code>T</code> 数据类型的长度。假设数组的起始地址为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.345ex" xmlns="http://www.w3.org/2000/svg" width="2.607ex" height="1.345ex" role="img" focusable="false" viewBox="0 -442 1152.3 594.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, -152.7) scale(0.707)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g></g></g></g></svg></mjx-container>，那么标记符<code>A</code> 指向数组的首地址，数组下标范围在 0 到 N-1，第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 个元素的地址为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.345ex" xmlns="http://www.w3.org/2000/svg" width="9.329ex" height="1.891ex" role="img" focusable="false" viewBox="0 -683 4123.2 835.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, -152.7) scale(0.707)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g></g><g data-mml-node="mo" transform="translate(1374.6, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2374.8, 0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(3278, 0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(3778.2, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 或者<code>A+i</code>。</p>
<h3 id="Pointer-Arithmetic">Pointer Arithmetic</h3>
<p>指针也可以做些简单的加减运算，而 <code>&amp;</code> 和<code>*</code>分别可以取一个变量的地址和解引用。例如访问数组 <code>E[i]</code> 的值(int)，也就是对指针<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="21.449ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9480.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, -150) scale(0.707)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g></g><g data-mml-node="mo" transform="translate(1162.2, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1551.2, 0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"></path></g><g data-mml-node="mi" transform="translate(2384.2, 0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(2850.2, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3370.2, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3942.2, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4553.5, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(5553.7, 0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(6053.7, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6398.7, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6787.7, 0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"></path></g><g data-mml-node="mi" transform="translate(7620.7, 0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(8086.7, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(8519.7, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(9091.7, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 解引用：</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">movl (%edx,%ecx,4),%eax</code></pre>
<h3 id="Nested-Arrays">Nested Arrays</h3>
<p>二维数组可以看作是一维数组，其类型为一维数组，本质上多维数组和一维数组没什么区别，都是连续分配。</p>
<p>例如</p>
<pre><code>int A[5][3];
</code></pre>
<p>相当于：</p>
<pre><code>typedef int row3_t[3];
row3_t A[5];
</code></pre>
<p>声明如下数组：</p>
<pre><code>T D[R][C];
</code></pre>
<p>元素 <code>D[i][j]</code> 的地址可以这样计算：</p>

<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="19.27ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8517.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, -150) scale(0.707)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g><g data-mml-node="mo" transform="translate(1429.7, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(2429.9, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2818.9, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3386.2, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(4108.4, 0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(5090.6, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(6090.8, 0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(6502.8, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(7114, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(7836.3, 0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>

<h3 id="Fixed-Size-Arrays">Fixed-Size Arrays</h3>
<p>固定大小的数组，翻译成汇编形式通常会对其进行优化，书上 239 页给了一个计算 2 个定长矩阵的乘积的汇编优化。</p>
<h3 id="Variable-Size-Arrays">Variable-Size Arrays</h3>
<p>早些年 C 语言只支持固定大小的数组（编译时确定），那时候对于变量大小的数组（不确定的），需要使用 <code>malloc</code> 这类系统调用来实现。而现在支持变量大小的数组了，因为变量已经指定了数组的大小，那么仍然可以根据变量的值计算出地址的。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">var_ele</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>同理，元素的地址可以这样计算：</p>

<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.374ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8121.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, -152.7) scale(0.707)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g></g><g data-mml-node="mo" transform="translate(1374.6, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(2374.8, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2763.8, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3331, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(4053.2, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4875.4, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5875.7, 0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(6287.7, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(6898.9, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mn" transform="translate(7621.1, 0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container>

<p>因为变长数组大小没法在编译时确定，那么就不有定长数组那样优化了，毕竟那个可以在编译时确定的。240 页同样给出了计算 2 个变长矩阵的乘积，很明显没有定长那样的优化了。这个例子也介绍了 <em>register spilling</em> 的情况，就是当寄存器不够了，会考虑把那些只读的局部变量、中间变量存储至内存（栈）上。</p>
<h2 id="Heterogeneous-Data-Structures">Heterogeneous Data Structures</h2>
<p>关于结构体 <code>struct</code>，也是在内存上分配一块连续的空间。而<code>union</code> 共用体则多种数据类型共同使用一块空间，取最大的数据类型作为总大小。</p>
<h3 id="Structures">Structures</h3>
<p>结构体指针指向结构体的第一个字节地址。</p>
<p>书上 243 页给出了访问结构体的汇编实现。虽然 C 语言访问结构体成员变量，使用名字就可以了，但是汇编形式是通过成员变量在数组首地址的偏移来定位的。</p>
<h3 id="Unions">Unions</h3>
<p>共用体总大小为其最大数据类型成员的大小。虽然共用体省空间，但是容易出 bug，因为它的成员变量是互斥访问的。</p>
<p>有时候还要考虑字节序问题，例如：</p>
<pre><code>union {
	double d;
	unsigned u[2];
} temp;
temp.u[0] = word0;
temp.u[1] = word1;
return temp.d;
</code></pre>
<p>这在 <code>little-endian</code> 里，<code>word0</code>是 <code>d</code> 的低字节，而 <code>word1</code> 是<code>d</code>的高字节，而 <code>big-endian</code> 刚好相反。</p>
<h3 id="Data-Alignment">Data Alignment</h3>
<p>关于数据对齐，要求数据的地址为必须为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.011ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 889 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g></g></g></svg></mjx-container>(2,4,8) 的整数倍。这么做主要是简化了处理器与内存的硬件接口设计，从而提高了性能。举个例子，假设处理器每次从内存中读取 8 个字节，那么得到地址必然是 8 的整数倍，假如 <code>double</code> 地址都是按 8 的倍数进行对齐，那么只要读取一次内存就可以了，不然的话，需要读取 2 次内存，然后拼接起来。</p>
<p>虽然 <code>IA32</code> 在不对齐的情况下也能正常工作，<code>Intel</code>还是建议内存对齐可以提高系统的性能。<code>Linux</code>是这么做的，当数据类型是 2 字节，那么地址必须按 <strong>2 的整数倍</strong> 对齐；而更大（int, int*, float, double）的数据类型，地址按照 <strong>4 的整数倍</strong> 进行对齐。这也意味着 <code>short</code>(*2) 的地址最后一位都是 0，类似地，<code>int</code>的地址最后两位都是 0（*4)。</p>
<p>编译器通常会放一些记号要求对其，例如下面汇编代码：</p>
<pre><code>.align 4
</code></pre>
<p>确保了后面的数据地址为 4 的整数倍。</p>
<p>一些库函数，例如<code>malloc</code>，也会返回一个内存对齐的指针。</p>
<p>结构体也会插入一些空隙，以确保满足内存对齐的要求，250 页给出了一些例子。</p>
<p>结构体还会在末尾插入一些空隙，以确保内存对齐的要求。例如</p>
<pre><code>struct S2 {
	int i;
	int j;
	char c;
};
</code></pre>
<p>看似对齐了，假设该结构体大小为 9 字节，那么当声明该类型的结构体数组时，<code>i</code>（9 的整数倍）,<code>j</code>就不对齐了。所以该结构体大小为 12 字节，在末尾填充了 3 字节空白。</p>
<h2 id="Putting-It-Together-Understanding-Pointers">Putting It Together: Understanding Pointers</h2>
<p>理解指针，其实很好理解，指针不就是变量的地址么，然后可以对变量取地址 <code>&amp;</code>、解引用<code>*</code> 等等操作。</p>
<p>需要注意的是指针有类型，而 <code>void*</code> 类型指针是通用类型，<code>malloc</code>就会返回一个通用类型的指针，需要自己类型转换。机器语言其实是没有指针这个类型的，只是 C 语言的一个抽象罢了。</p>
<p><code>NULL</code>指针不指向任何变量。</p>
<p>指针转换类型需要注意优先级。例如 <code>char *p</code>，<code>(int *)p + 7</code> 和<code>(int *)(p+7)</code>是不一样的，前者计算<code>p+28</code>，后者计算<code>p+7</code>。</p>
<p>指针可以指向函数，即函数指针。</p>
<h2 id="Life-in-the-Real-World-Using-the-gdb-Debugger">Life in the Real World: Using the gdb Debugger</h2>
<p>这节讲了 <code>GDB</code> 的常用参数，需要的时候可以查书，255 页。</p>
<h2 id="Out-of-Bounds-Memory-References-and-Buffer-Overflow">Out-of-Bounds Memory References and Buffer Overflow</h2>
<p>256 页这节给了一个例子，讲关于缓冲区溢出的问题，用了一个非常严重的 <code>gets</code> 函数，当输入的字符串长度大于缓冲区（定义的数组）大小时，将有可能覆盖（破坏）掉 <code>%ebp</code> 保存的帧指针，甚至覆盖掉返回地址！更有可能覆盖掉主调函数的内容！</p>
<p>虽然 C 语言代码看不出什么问题，但是这是一个非常严重的漏洞。所以现在编译器都会警告使用 <code>gets</code> 调用，可以考虑用<code>fgets</code>，因为它指定了缓冲区的大小，从而避免缓冲区溢出。不过，很多库函数都有这个问题，例如<code>strcpy</code>,<code>strcat</code>,<code>sprintf</code>，它们都不考虑缓冲区大小！从而导致缓冲区溢出！</p>
<p>前面提到有可能覆盖掉返回地址，那么就有人利用这个漏洞进行攻击，做一些不应该做的事情。比如把恶意代码注入内存，然后通过缓冲区溢出覆盖返回地址到恶意代码地址，那么当函数 <code>ret</code> 的时候，不是返回主调函数，而是执行恶意代码了！</p>
<p>书上举了一个 1988 年的网络蠕虫，通过互联网传播，缓冲区溢出导致被非法入侵。所以编程的时候需要注意对外接口应该刀枪不入。</p>
<h2 id="Thwarting-Buffer-Overflow-Attacks">Thwarting Buffer Overflow Attacks</h2>
<p>这节讲了操作系统的 3 个手段用于防止缓冲区溢出攻击。</p>
<h3 id="Stack-Randomization">Stack Randomization</h3>
<p>这种方式主要就是，每次程序运行的时候，栈变量的地址是不确定（随机，变化范围非常大）的。这样就能防止恶意代码注入系统了，因为恶意代码的地址也是不确定的了 - -</p>
<p>早些年，因为栈变量基本都是确定（哪怕不同机器，只要操作系统相同）的，那么非常容易受到攻击，例如一个网络服务器程序，攻击者攻破了，很容易将它传播到其他机器（例如服务器）上面。这个现象也叫做<em>security monoculture</em>。</p>
<p>栈随机化也是<em>address-space layout randomization</em>（简称 ASLR）的一类，主要就是每次运行，程序的不同部分，例如代码块、库代码、栈、全局变量、堆数据加载到不同的内存区域。</p>
<p>然而随机化也不是最安全的，攻击者仍可以爆破，重复攻击。通常在恶意代码前加入一系列 <code>nop</code> 指令（这个指令啥都不做，除了 PC 会 <code>+1</code>），只要程序跳到这些<code>nop</code> 指令，那么就会滑到恶意代码（执行）里。这个术语叫做<em>nop sled</em>。</p>
<h3 id="Stack-Corruption-Detection">Stack Corruption Detection</h3>
<p>这个方式可以检测出缓冲区是否溢出。主要实现就是在汇编代码的缓冲区上面放一个 <code>canary</code> 值（存放到栈上）。263 页图 3.3 给出了 <code>canary</code> 在栈的位置。刚开始设置 <code>canary</code> 的值为随机（不容易被攻击）的，然后保存。函数返回前，检查一下 <code>canary</code> 的值是否变化，变化了就说明缓冲区溢出了，报错。最新版本的 <code>gcc</code> 会自动检测函数是否会产生缓冲区溢出，然后插入<code>canary</code>。</p>
<p>具体可看 263 页例子。</p>
<h3 id="Limiting-Executable-Code-Regions">Limiting Executable Code Regions</h3>
<p>这个机制主要是限制代码的区域是否可执行、可读、可写。编译器生成的代码区域应该可执行，而其他区域应该不能执行。</p>
<p>由于历史原因，<code>x86</code>结构用 1 个比特位来判断是否可读和可执行。然而栈必须可读可写，那么也意味着可执行。如果要控制是否可执行，效率非常低。</p>
<p>AMD 在 64 位系统引入了 <code>NX</code> 位，来代表不可执行，很好地解决了这个问题，后来 <code>Intel</code> 也支持了，从而可以通过硬件判断是否可执行，提高了效率。</p>
<p>上面这三种机制，大大提高了系统的安全性。</p>
<h2 id="x86-64-Extending-IA32-to-64-Bits">x86-64: Extending IA32 to 64 Bits</h2>
<p>这一节主要讲 IA32 位汇编衍生到 64 位，没怎么细看。</p>
<p>06 年的时候 32 位处理器使用的就很广泛了，然而从 1985 年刚从 16 为衍生出的 32 位 <code>i386</code> 微处理器，后来一系列处理器（<code>i486</code>,<code>i586</code>,<code>i686</code>）增加了很多特性，但是 <code>gcc</code> 默认都不使用这些特性，主要还是为了考虑向后兼容，比如前面提到的 <code>cmov</code> 指令，在 64 位系统才会默认使用。</p>
<p>32 位由于内存有限，很多应用都无法满足，比如大数据、数据库应用，都因为内存受限在编程上面遇到很多麻烦，这类应用需要 <em>out-of-core</em> 算法来实现，就是将内存中的数据暂存到硬盘上面存储。</p>
<p>最早引出 64 位处理器是在 92 年的由 <em>Digital Equipment Corporation</em> 引出的 <em>Alpha</em> 处理器，当时主要面对的是高端机器，<em>Intel</em>没怎么重视。</p>
<p>后来 <em>Intel</em> 第一次引出了 64 位处理器 <em>Itanium</em> 系列，基于全新的 <em>IA64</em> 指令集，没考虑向后兼容。<em>IA64</em>指令集可以将多条指令放到一块存储器中，可以提高机器的并行效率，但是实现起来很难，最后也没达到理想的性能。不过它可以在兼容模式下运行 32 位程序，但是性能非常糟糕，还没 32 位处理器的快，又贵。</p>
<p>紧接着 <em>Intel</em> 的对手 <em>AMD</em> 抓住了这个机会，03 年它引出了基于 <em>x86-64</em> 指令集的 64 位处理器，可以很好的 <strong> 向后兼容 </strong>，性能也非常好，从而也抓住了计算机高端市场，后来它把这个指令集改名为<em>AMD64</em>，最后还是<em>x86-64</em> 这个名字比较流行。</p>
<p><em>Intel</em>意识到了从 <em>IA32</em> 衍生到 <em>IA64</em> 位是行不通的，所以后来 04 年也开始支持 <em>x86-64</em> 的<em>Pentium 4 Xeon</em>处理器诞生了。因为之前 <em>Intel</em> 用<em>IA64</em>这个名字来表示 <em>Itanium</em>，遇到了取名困难，最后，它们把<em>x86-64</em> 取名为<em>IA32-EM64T</em>。</p>
<p>在编译器这边，gcc 一直保持 <em>i386</em> 的兼容性而没考虑用新特性（除非命令行参数指定）。直到 <em>x86-64</em> 出现了，gcc 才放弃向后兼容，开始挖掘这些新特性来提高处理器的运行性能。</p>
<p>简要说下 <em>x86-64</em> 的特点：</p>
<ul>
<li>指针、整数 64 位长度，支持 8,16,32 和 64 位数据类型</li>
<li>通用寄存器从 8 个扩展到 16 个，由于寄存器增多了，很多局部变量、中间变量尽可能使用寄存器存储；函数参数（最多 6 个）也开始优先利用寄存器来传递，而不是利用栈空间了，大大减少了栈空间使用。</li>
<li>尽可能使用 <code>cmov</code> 来代替 <code>conditional</code> 操作</li>
<li>浮点数运算有专门的寄存器，使用专用的 <em>SSEv2</em> 指令集，而不像 <em>IA32</em> 基于栈来实现</li>
<li>很多函数基本不用栈帧了，只有当寄存器无法保存所有局部变量的时候，才考虑使用栈帧。</li>
<li>没有帧指针了，使用栈指针来定位变量。很多函数一开始就分配了它们所要的栈空间大小，栈指针 <strong> 固定 </strong> 位置，所以 <code>%ebp</code> 没必要存在了。在调用函数的时候，主调函数会 <code>pushq</code><strong> 返回地址 </strong> 到栈上，被调函数通过 <code>ret</code> 返回的时候，将 <strong> 返回地址 </strong><code>popq</code> 了，从而主调函数的栈指针位置不变。</li>
</ul>
<h2 id="Machine-Level-Representations-of-Floating-Point-Programs">Machine-Level Representations of Floating-Point Programs</h2>
<p>浮点数实现有多种。其中一种是<em>x87</em>，至今仍在使用；另一种是<em>SSE</em>，为了支持多媒体而添加的。</p>
<p><em>x87</em>是协处理器，有自己的寄存器和指令集，基于栈模型，专门做浮点运算。</p>
<p><em>SSE</em>指令集基于寄存器，和整数操作类似，只是指令不一样罢了。</p>

    
  </div>

</article>


   
       <div class="original">
    <ul>
        <li>本文标题：CSAPP 第三章总结：Machine-Level Representation of Programs</li>
        <li>本文字数：7.9k</li>
        <li>本文作者：Netcan</li>
        <li>发布时间：2017年01月31日 - 14时33分</li>
        <li>最后更新：2022年12月09日 - 19时02分</li>
        <li>原始链接：<a href="https://netcan.github.io/2017/01/31/CSAPP%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%80%BB%E7%BB%93%EF%BC%9AMachine-Level-Representation-of-Programs/">https://netcan.github.io/2017/01/31/CSAPP第三章总结：Machine-Level-Representation-of-Programs/</a></li>
        <li>版权声明：<i class="icon icon-cc"></i><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" rel="external nofollow noopener noreferrer" target="_blank">"署名-非商用-相同方式共享 3.0"</a>转载请保留原文链接及作者。</li>
    </ul>
</div>

   

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Netcan</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/01/29/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/02/06/CSAPP%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%BB%E7%BB%93%EF%BC%9AProcessor-Architecture/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>
<script>
    $(".article-content img").wrap(function() {
        return '<a data-fancybox href="' + $(this).attr("src") + '"/>';
    });
</script>


  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '893a4103795fc66cd8e7',
  clientSecret: '35c92c3dca938831b67dc22e46d64bc9073ebacf',
  repo: 'netcan.github.io',
  owner: 'Netcan',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['Netcan'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
