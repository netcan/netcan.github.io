<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>构造、析构期间被调虚函数发生的惨案 | Netcan on Programming</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C/C++," />
  

  <meta name="description" content="最近有个问题出现长达一个月，经过两次修改未能解决，大致场景如下： 一个多态对象 Children 被注册回调（m_observer对象位于基类 Base 中），正好在析构函数里面回调，导致 crash。 class Base &amp;#123;     &#x2F;&#x2F; ... protected:     std::shared_ptr&lt;Observer&gt; m_observer; &amp;#125; class">
<meta property="og:type" content="article">
<meta property="og:title" content="构造、析构期间被调虚函数发生的惨案">
<meta property="og:url" content="https://netcan.github.io/2020/05/30/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E6%9C%9F%E9%97%B4%E8%A2%AB%E8%B0%83%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E7%9A%84%E6%83%A8%E6%A1%88/index.html">
<meta property="og:site_name" content="Netcan on Programming">
<meta property="og:description" content="最近有个问题出现长达一个月，经过两次修改未能解决，大致场景如下： 一个多态对象 Children 被注册回调（m_observer对象位于基类 Base 中），正好在析构函数里面回调，导致 crash。 class Base &amp;#123;     &#x2F;&#x2F; ... protected:     std::shared_ptr&lt;Observer&gt; m_observer; &amp;#125; class">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-30T02:01:57.000Z">
<meta property="article:modified_time" content="2022-12-09T11:02:08.600Z">
<meta property="article:author" content="Netcan">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/site.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-174901164-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d2c292719a76d8c0fa7f9874379cfd25";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="Netcan on Programming" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">ROOT</span>
  

  <link rel="stylesheet" href="/css/prism.css">

<div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">ROOT</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="post-构造、析构期间被调虚函数发生的惨案" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">构造、析构期间被调虚函数发生的惨案</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.05.30</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Netcan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>最近有个问题出现长达一个月，经过两次修改未能解决，大致场景如下：</p>
<p>一个多态对象 <code>Children</code> 被注册回调（<code>m_observer</code>对象位于基类 <code>Base</code> 中），正好在析构函数里面回调，导致 crash。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Observer<span class="token operator">></span> m_observer<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Children</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span>
    <span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Register 函数，接口有锁保护，避免回调时竞争访问 cb 句柄</span>
        m_observer<span class="token operator">-></span><span class="token function">Register</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Children<span class="token operator">::</span>callback<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>第一次修改是通过在基类的 base 里面对 observable 对象取消回调订阅，来避免回调时对象不存在。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        m_observer<span class="token operator">-></span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取消回调</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>后来发现每个包含 <code>m_observer</code> 的类都需要这么干，这样就多了很多重复代码，不够简洁，于是考虑进一步优化，干脆在 <code>Observer</code> 析构函数里面去统一取消回调订阅好了。这样析构函数啥代码也不用写：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>结果出现了这种场景，在 <code>Children</code> 对象析构时正好发生回调，这时候底层 <code>Observable</code> 拿到了 <code>m_observer</code> 对象的计数，导致 <code>m_observer</code> 没有去执行 <strong> 析构</strong>，这时候回调对象刚好不存在了，导致 crash。</p>
<p>这里再延伸一些，这里的 <code>Observable</code> 持有的是 <code>Observer</code> 对象的弱指针，从而实现 <strong> 弱回调 </strong>，也就是说，<code>Observable</code> 通过 <strong> 弱指针 </strong> 提升到 <strong> 强指针 </strong> 来判断对方 <code>Observer</code> 是否还活着，如果活着就调对方的注册的回调函数，否则不调。理想是很美好的，实际由于 <strong> 组合模式 </strong> 打破了这种原则，因为通过组合模式，持有的仅仅是 <code>Observer</code>，当外层对象析构时候发生回调，相当于<code>Observer</code> 被<code>Observable</code>偷走了，这时候回调外层对象已经不存在了，如果采用继承 <code>Observer</code> 接口的方式，那么就不会存在这个问题，因为对象是个完整的 <code>Observer</code> 对象。</p>
<p>这也是 <strong> 多继承 </strong> 一个 <code>Observer</code> 接口的优势，对象是 <strong> 完整 </strong> 的，只要拿到了 <code>Observer</code> 强指针，就能保证对象还 <strong> 活着</strong>。</p>
<p>当然我写这个不是为了鼓吹什么多继承，批判组合模式，只是双方都有应用场景罢了，不能一概而论，得出组合优于继承的结论。</p>
<p>问题还是要解决的，回调最初的方案，是不是在 <code>Base</code> 里面手动解绑回调就能解决问题了呢？</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        m_observer<span class="token operator">-></span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取消回调</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>分析一下：</p>
<ol>
<li>假设回调在 <code>m_observer-&gt;Register(nullptr)</code> 之<strong>前 </strong> 发生，那么由于 <code>Register</code> 接口带锁保护，就会等待回调结束后在执行 <code>m_observer-&gt;Register(nullptr)</code> 语句，这个期间可以保证对象是 <strong> 活着 </strong> 的。</li>
<li>假设回调在 <code>m_observer-&gt;Register(nullptr)</code> 之<strong>后 </strong> 发生，由于回调被取消了，所以不会发生回调，这也很安全。</li>
</ol>
<p>实际运行过程中还是会 crash。这就有点不可思议了，继续分析问题，发现注册的回调是子类的虚函数：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Children</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span>
    <span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Register 函数，接口有锁保护，避免回调时竞争访问 cb 句柄</span>
        m_observer<span class="token operator">-></span><span class="token function">Register</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Children<span class="token operator">::</span>callback<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 虚函数作为回调</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>在上述情况 1 的时候发生回调，调的是子类的虚函数<code>callback</code>，而每次调用栈的顶端永远是空地址：</p>
<pre class="language-none"><code class="language-none">signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0
Cause: null pointer dereference
    x0  0000007deaeb1498  x1  000000000000009f  x2  0000007def601a34  x3  0000000000000004
    x4  0000000000020002  x5  0000007def601a20  x6  0000000000000000  x7  7f7f7f7f7f7f7f7f
    x8  0000000000000000  x9  27da922d41dff5aa  x10 0000007def6014a0  x11 0000000000000042
    x12 0000000000000000  x13 0000000000000000  x14 0000000000000004  x15 0000141f5dfff2d0
    x16 0000007e05eddd98  x17 0000007e04b76e6c  x18 0000007deeaa8000  x19 0000007def601a20
    x20 0000000000000000  x21 0000007deaeb1498  x22 0000000000000004  x23 0000007def601a34
    x24 000000000000009f  x25 0000007def602020  x26 0000000000000000  x27 0000000000000001
    x28 0000007e047da458  x29 0000007def601a10
    sp  0000007def601650  lr  0000007e05dc0b8c  pc  0000000000000000
backtrace:
      #00 pc 0000000000000000  &lt;unknown&gt;
      #01 pc 00000000003cfddc ...</code></pre>
<p>函数地址为空，只有虚函数可能发生了，我写了原型程序验证了一下，模拟情况 1 发生的行为：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证对象在回调期间还活着</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Children</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 虚函数作为回调</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"virtual func call!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Children<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token keyword">new</span> Children<span class="token punctuation">;</span>
    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>c<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            c<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用子类的虚函数</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (1)</span>
    <span class="token keyword">delete</span> c<span class="token punctuation">;</span> <span class="token comment">// (2)这时候会在基类的析构函数中等待</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// crash !!</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>果然 crash 了，看看调用栈如下：</p>
<pre class="language-none"><code class="language-none">#0  0x0000000000000000 in ?? ()
#1  0x0000555555554f19 in &lt;lambda()&gt;::operator()(void) const (__closure&#x3D;0x555555769e98) at tt.cpp:43
#2  0x0000555555555229 in std::__invoke_impl&lt;void, main()::&lt;lambda()&gt; &gt;(std::__invoke_other, &lt;lambda()&gt; &amp;&amp;) (__f&#x3D;...) at &#x2F;usr&#x2F;include&#x2F;c++&#x2F;7&#x2F;bits&#x2F;invoke.h:60
#3  0x0000555555555034 in std::__invoke&lt;main()::&lt;lambda()&gt; &gt;(&lt;lambda()&gt; &amp;&amp;) (__fn&#x3D;...) at &#x2F;usr&#x2F;include&#x2F;c++&#x2F;7&#x2F;bits&#x2F;invoke.h:95
...</code></pre>
<p>在看看阶段 <code>(1)</code> 对象 <code>c</code> 的虚函数表：</p>
<pre class="language-none"><code class="language-none">vtable for &#39;Children&#39; @ 0x555555756c88 (subobject @ 0x555555769e70):
[0]: 0x55555555564a &lt;Children::~Children()&gt;
[1]: 0x555555555680 &lt;Children::~Children()&gt;
[2]: 0x55555555562e &lt;Children::func()&gt;</code></pre>
<p>在阶段<code>(2)</code>，对象的虚函数表如下：</p>
<pre class="language-none"><code class="language-none">vtable for &#39;Children&#39; @ 0x555555756cb0 (subobject @ 0x555555769e70):
[0]: 0x5555555555ce &lt;Base::~Base()&gt;
[1]: 0x555555555602 &lt;Base::~Base()&gt;
[2]: 0x0</code></pre>
<p>可以得出结论，在基类的析构期间，子类的虚函数表已经清空，这时候调子类的虚函数已经是不安全的了，虽然这时候对象还活着，但 <strong> 不完整</strong>。所以得通过加接口，在析构函数之前去释放回调，这样才是安全的了。</p>
<p>科目二，《Effective C++》也指出，不能在构造、析构函数中调虚函数，原因是这期间虚函数 <strong> 没有多态性 </strong>，所以即使编码遵守原则，在多线程场景下，也防不住有析构期间<strong> 被调用 </strong> 虚函数的情况，特别是被调的时候。</p>
<p><strong>2020/6/2 更新</strong>
前面说通过加接口，在析构函数之前去释放回调，这样不够优雅，因为子类重写得记得多了这么一个接口需要调用，所以继续重构，达到了如下完美的方案：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token operator">::</span><span class="token class-name">enable_share_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Base</span><span class="token operator">></span> <span class="token comment">// 需要继承这个类从而拿到 this 的智能指针</span></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Observer<span class="token operator">></span> m_observer<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Children</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span>
    <span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Register 函数，接口有锁保护，避免回调时竞争访问 cb 句柄</span>
        <span class="token comment">// 错误写法，this 随时可能析构掉： m_observer->Register(std::bind(&amp;Children::callback, this));</span>
        std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Base<span class="token operator">></span> wpBase <span class="token operator">=</span> <span class="token function">enable_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拿到 this 的弱指针</span>
        m_observer<span class="token operator">-></span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">[</span>wpBase<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Base<span class="token operator">></span> spBase <span class="token operator">=</span> wpBase<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弱指针提升到强指针</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>spBase<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若对象还活着，则调用回调，这里也可以保证对象是完整的。</span>
                <span class="token keyword">return</span> std<span class="token operator">::</span>static_point_cast<span class="token operator">&lt;</span>Children<span class="token operator">></span><span class="token punctuation">(</span>spBase<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>本质来说，回调传递 <code>this</code> 指针是不安全的，所有 <strong> 裸指针 </strong> 都是有风险的，如果用智能指针封装，就能保证对象的完整性了，在这个场景下，只需要将 <code>this</code> 转换成智能指针，这时候 <code>std::enable_share_from_this</code> 就派上用场了。</p>

    
  </div>

</article>


   
       <div class="original">
    <ul>
        <li>本文标题：构造、析构期间被调虚函数发生的惨案</li>
        <li>本文字数：1.7k</li>
        <li>本文作者：Netcan</li>
        <li>发布时间：2020年05月30日 - 10时01分</li>
        <li>最后更新：2022年12月09日 - 19时02分</li>
        <li>原始链接：<a href="https://netcan.github.io/2020/05/30/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E6%9C%9F%E9%97%B4%E8%A2%AB%E8%B0%83%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E7%9A%84%E6%83%A8%E6%A1%88/">https://netcan.github.io/2020/05/30/构造、析构期间被调虚函数发生的惨案/</a></li>
        <li>版权声明：<i class="icon icon-cc"></i><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" rel="external nofollow noopener noreferrer" target="_blank">"署名-非商用-相同方式共享 3.0"</a>转载请保留原文链接及作者。</li>
    </ul>
</div>

   

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Netcan</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/03/12/pImpl%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2020/06/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%97%E5%85%BD%E6%A3%8B%E6%B8%B8%E6%88%8F/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '893a4103795fc66cd8e7',
  clientSecret: '35c92c3dca938831b67dc22e46d64bc9073ebacf',
  repo: 'netcan.github.io',
  owner: 'Netcan',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['Netcan'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
