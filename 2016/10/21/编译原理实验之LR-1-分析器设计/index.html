<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>编译原理实验之 LR(1) 分析器设计 | Netcan on Programming</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C/C++,编译原理," />
  

  <meta name="description" content="终于做完第三个实验了，代码地址：https:&#x2F;&#x2F;github.com&#x2F;netcan&#x2F;compilingTheory，项目地址：http:&#x2F;&#x2F;115.159.147.250:666&#x2F;LR&#x2F;，第一次进入需要加载库，比较耗时，请耐心等待，效果图：  先来吐槽下，据说这个实验是最难的一个实验，当然也是最后的一个实验了。在我们实验室上一届学长只有一个人写出来，可见其难度。  然而我并不觉得有什么难的，当我上">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理实验之 LR(1) 分析器设计">
<meta property="og:url" content="https://netcan.github.io/2016/10/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B9%8BLR-1-%E5%88%86%E6%9E%90%E5%99%A8%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Netcan on Programming">
<meta property="og:description" content="终于做完第三个实验了，代码地址：https:&#x2F;&#x2F;github.com&#x2F;netcan&#x2F;compilingTheory，项目地址：http:&#x2F;&#x2F;115.159.147.250:666&#x2F;LR&#x2F;，第一次进入需要加载库，比较耗时，请耐心等待，效果图：  先来吐槽下，据说这个实验是最难的一个实验，当然也是最后的一个实验了。在我们实验室上一届学长只有一个人写出来，可见其难度。  然而我并不觉得有什么难的，当我上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/netcan/compilingTheory/master/LR.gif">
<meta property="og:image" content="http://7xqytu.com1.z0.glb.clouddn.com//2016/10/QQ%E6%88%AA%E5%9B%BE20161021212712.png">
<meta property="og:image" content="http://7xibui.com1.z0.glb.clouddn.com//2016/10/screenshot-window-2016-10-21-114458.png">
<meta property="og:image" content="http://7xibui.com1.z0.glb.clouddn.com//2016/10/screenshot-window-2016-10-21-114315.png">
<meta property="article:published_time" content="2016-10-21T13:15:07.000Z">
<meta property="article:modified_time" content="2022-12-09T11:02:08.602Z">
<meta property="article:author" content="Netcan">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/netcan/compilingTheory/master/LR.gif">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/site.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-174901164-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d2c292719a76d8c0fa7f9874379cfd25";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Netcan on Programming" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">ROOT</span>
  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/>
<link rel="stylesheet" href="/css/prism.css">

<div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">ROOT</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%20Prod%20%E7%B1%BB"><span class="toc-text">产生式 Prod 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%9B%86%20Item%20%E7%B1%BB"><span class="toc-text">项目集 Item 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%20%E7%B1%BB"><span class="toc-text">LR类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-text">空串处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PL0%20%E6%96%87%E6%B3%95%E6%B5%8B%E8%AF%95"><span class="toc-text">PL0文法测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-auto-Bug"><span class="toc-text">for auto &amp; Bug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-text">前端处理</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-编译原理实验之LR-1-分析器设计" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">编译原理实验之 LR(1) 分析器设计</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.10.21</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Netcan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>终于做完第三个实验了，代码地址：<a target="_blank" rel="noopener" href="https://github.com/netcan/compilingTheory">https://github.com/netcan/compilingTheory</a>，项目地址：<a target="_blank" rel="noopener" href="http://115.159.147.250:666/LR/">http://115.159.147.250:666/LR/</a>，<strong>第一次进入需要加载库，比较耗时，请耐心等待</strong>，效果图：
<img src="https://raw.githubusercontent.com/netcan/compilingTheory/master/LR.gif" alt="https://raw.githubusercontent.com/netcan/compilingTheory/master/LR.gif"></p>
<p>先来吐槽下，据说这个实验是最难的一个实验，当然也是最后的一个实验了。在我们实验室上一届学长只有一个人写出来，可见其难度。</p>
<p><img src="http://7xqytu.com1.z0.glb.clouddn.com//2016/10/QQ%E6%88%AA%E5%9B%BE20161021212712.png" alt="http://7xqytu.com1.z0.glb.clouddn.com//2016/10/QQ%E6%88%AA%E5%9B%BE20161021212712.png"></p>
<p>然而我并不觉得有什么难的，当我上课听懂老师讲 LR 语法分析的时候，我就疑惑了，难点在哪？学长说难在自动机的构建上，自动机比较难拍，不好用数据结构来描述。这当然给了我巨大信心，回去不到一天把 LR 分析器核心拍出来了，在没有参考任何代码、龙书，仅看着教科书上的算法来写的。</p>
<h2 id="产生式 Prod 类">产生式 <code>Prod</code> 类</h2>
<p>我来说下具体是怎么实现的吧，用面向对象来写比较好写，绝对比面向过程好写。先来看看我设计的最小的类<code>Prod</code>（为减小篇幅已删除无关紧要的函数）。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Prod</span> <span class="token punctuation">{</span> <span class="token comment">// 这里是存放形如 X-&gt;abc 的形式，不存在多个候选式</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">char</span> noTerminal<span class="token punctuation">;</span> <span class="token comment">// 产生式左部非终结符名字</span>
		string right<span class="token punctuation">;</span> <span class="token comment">// 产生式右部</span>
		set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> additionalVt<span class="token punctuation">;</span> <span class="token comment">// 附加终结符</span>
		<span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Prod <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> Prod <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> a<span class="token punctuation">.</span>noTerminal <span class="token operator">==</span> b<span class="token punctuation">.</span>noTerminal <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>right <span class="token operator">==</span> b<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Prod <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> a<span class="token punctuation">.</span>noTerminal <span class="token operator">==</span> c<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">Prod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">&amp;</span>noTerminal<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> right<span class="token punctuation">,</span> <span class="token keyword">const</span> set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> additionalVt<span class="token punctuation">)</span><span class="token operator">:</span>
			<span class="token function">noTerminal</span><span class="token punctuation">(</span>noTerminal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">additionalVt</span><span class="token punctuation">(</span>additionalVt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>这个类是存放产生式的，存放形如 <code>A-&gt;Bc</code>，这里的<code>noTerminal</code> 就是左边的 <code>A</code>，<code>right</code> 就是右边的 <code>Bc</code>，而<code>additionalVt</code> 是<code>LR(1)</code>的项目集的 <strong> 搜索符 </strong>，长度为 1 所以叫<code>LR(1)</code>。我重载了<code>==</code> 符号，后面用来搜索项目集 / 文法中是否有这个产生式简直不能再方便，构造函数也能快速构造产生式，无疑为后面项目集中插入产生式提供了方便。</p>
<h2 id="项目集 Item 类">项目集 <code>Item</code> 类</h2>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span> <span class="token comment">// 项目集</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		vector<span class="token operator">&lt;</span>Prod<span class="token operator">&gt;</span> prods<span class="token punctuation">;</span> <span class="token comment">// 项目集产生式</span>
		<span class="token keyword">static</span> set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> Vn<span class="token punctuation">;</span> <span class="token comment">// 非终结符</span>
		<span class="token keyword">static</span> set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> Vt<span class="token punctuation">;</span> <span class="token comment">// 终结符</span>
		<span class="token keyword">static</span> set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> Symbol<span class="token punctuation">;</span> <span class="token comment">// 所有符号</span>
		<span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Item <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> Item <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>prods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> b<span class="token punctuation">.</span>prods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p<span class="token operator">:</span> a<span class="token punctuation">.</span>prods<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 选择 a 的每个产生式</span>
					<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>prods<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>prods<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> b<span class="token punctuation">.</span>prods<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 找不到</span>
						<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
					<span class="token keyword">else</span>  <span class="token punctuation">{</span><span class="token comment">// 找到的话判断附加终结符是否都相等</span>
						<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>additionalVt <span class="token operator">!=</span> it<span class="token operator">-&gt;</span>additionalVt<span class="token punctuation">)</span>
							<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>prod<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>项目集 <code>Item</code> 类中，<code>prods</code>向量存放这个项目集的所有 <strong> 项目 </strong>（即产生式 +<strong> 搜索符 </strong>），而<code>Vn/Vt</code> 集合存放了 <strong> 所有 </strong> 产生式的非终结符 / 终结符，<code>Symbol</code>仅仅是 <code>Vn/Vt</code> 的并集，为后面 <code>GOTO</code> 函数枚举符号提供了方便，<code>add</code>方法为项目集插入项目。这里最重要的就是重载 <code>==</code> 符号了，它是判断两个项目集是否相等的关键，判断也很简单，首先判断两个项目集的项目数量是否相等，若相等进一步判断是否所有的 <strong> 项目 </strong> 都相等，这里就展现了前面重载 <code>==</code> 的优点（当然还需要判断 <strong> 搜索符 </strong> 是否也都相等）。能判断两个项目集是否相等就好办了，后面求 <strong> 项目集规范族 </strong> 插入项目就简单了。</p>
<p>还需要注意的一点，<code>Prod</code>类已经重载 <code>==</code> 了，为啥项目集 <code>prods</code> 用向量来存，而不是直接用集合来存？这样就不用判等了，还能二分查找提高了查询效率。但是我考虑到用集合来存的话，会按照字典序来排，但是这样还要重载 <code>&lt;</code>，会打乱产生式的顺序，所以我后面的<code>LR</code> 类来存放文法产生式、<strong>项目集规范族 </strong> 也是用向量来存（插入的时候判等就是了），而不是集合，以免打乱了顺序。</p>
<h2 id="LR 类"><code>LR</code>类</h2>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">LR</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		Item G<span class="token punctuation">;</span> <span class="token comment">// 文法 G</span>
		<span class="token keyword">enum</span> <span class="token class-name">actionStat</span><span class="token punctuation">{</span>
			ACCEPT<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>
			SHIFT<span class="token punctuation">,</span>
			REDUCE<span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>

		vector<span class="token operator">&lt;</span>Item<span class="token operator">&gt;</span> C<span class="token punctuation">;</span> <span class="token comment">// 项目集规范族</span>
		map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> GOTO<span class="token punctuation">;</span> <span class="token comment">// goto 数组，项目集 &lt;int, int&gt;=char</span>
		map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> pair<span class="token operator">&lt;</span>actionStat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> ACTION<span class="token punctuation">;</span> <span class="token comment">// Action 数组，Action[(i, a)]=(s|r)j</span>
		map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> FIRST<span class="token punctuation">;</span> <span class="token comment">// first 集</span>
		set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求 first 集</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> inStr<span class="token punctuation">;</span> <span class="token comment">// 输入串 / 栈</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> status<span class="token punctuation">;</span> <span class="token comment">// 状态栈</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> parse<span class="token punctuation">;</span> <span class="token comment">// 分析栈</span>
		Item <span class="token function">closure</span><span class="token punctuation">(</span>Item I<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求该项目的闭包</span>
		Item <span class="token function">Goto</span><span class="token punctuation">(</span><span class="token keyword">const</span> Item<span class="token operator">&amp;</span> I<span class="token punctuation">,</span> <span class="token keyword">char</span> X<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求 I 经过 X 到达的项目集</span>
		<span class="token keyword">void</span> <span class="token function">items</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求项目集状态机 DFA！!</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加产生式</span>
		<span class="token keyword">void</span> <span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LR(1)分析</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>这是最后一个类了，重点说说。<code>G</code>用来存放输入的文法，把它看成一个项目集吧。<code>C</code>是 <strong> 项目集规范族 </strong>，也就是项目集的集合，用向量来存。<code>actionStat</code> 为枚举类型，用于表示 <code>ACTION</code> 的动作类型。<code>GOTO</code>用于存放自动机 DFA 上 <strong> 边</strong>，边 <code>w(i, j)=X</code>，<code>ACTION</code> 用于存放动作，<code>Action[(i, X)] = ((s|r)j)|acc</code>，即当状态 <code>i</code> 遇到 <strong> 终结符 X</strong>的时候采取的动作，移进 / 规约 / 接受。<code>FIRST</code>集合存放各个 <strong> 非终结符 </strong> 的<code>FIRST</code>集合，<code>first</code>方法求集合会记忆化存储到 <code>FIRST</code> 集合里。接下来就是那三个栈了，还有 <code>Closure</code>、<code>Goto</code>、<code>items</code>、<code>parser</code> 这几个方法了，书上有我就不细讲了，设计好这几个数据结构，写起来会轻松很多。</p>
<h2 id="空串处理">空串处理</h2>
<p>那时候我的分析器还不能处理形如 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="6.27ex" height="1.67ex" role="img" focusable="false" viewBox="0 -716 2771.6 738"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(1027.8, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2305.6, 0)"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path></g></g></g></svg></mjx-container> 的产生式，书上、指导书给的文法，都没这类产生式。我就想，是不是 <code>LR</code> 不能处理空串啊？因为 <code>LR</code> 的<code>DFA</code>构建过程中，如果引出 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.054ex" height="1.072ex" role="img" focusable="false" viewBox="0 -452 466 474"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path></g></g></g></svg></mjx-container> 这条边，那就是 <code>NFA</code> 了，这样还要把它化为 <code>DFA</code>，那就很麻烦了。请教了一下李老师，老师说处理<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="6.27ex" height="1.67ex" role="img" focusable="false" viewBox="0 -716 2771.6 738"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(1027.8, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2305.6, 0)"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path></g></g></g></svg></mjx-container> 项目的时候，项目直接写成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="5.217ex" height="1.645ex" role="img" focusable="false" viewBox="0 -716 2305.8 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(1027.8, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(2027.8, 0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g></g></g></svg></mjx-container>，也就是说求<code>GOTO</code> 函数的时候不要把 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.054ex" height="1.072ex" role="img" focusable="false" viewBox="0 -452 466 474"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path></g></g></g></svg></mjx-container> 当终结符 / 非终结符处理，不要引出 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.054ex" height="1.072ex" role="img" focusable="false" viewBox="0 -452 466 474"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path></g></g></g></svg></mjx-container> 边。</p>
<p>恍然大悟，回去修改了下程序，果然能处理这类产生式了。</p>
<h2 id="PL0 文法测试"><code>PL0</code>文法测试</h2>
<p>后来有人给了一组数据，即 <code>PL0</code> 文法，测试失败。这里给下数据，做了点小修改，因为有些符号和我程序内部符号冲突了，所以只是做了简单的替换。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">A<span class="token operator">-&gt;</span>B<span class="token punctuation">,</span>
B<span class="token operator">-&gt;</span>CEFH
B<span class="token operator">-&gt;</span>H
B<span class="token operator">-&gt;</span>CH
B<span class="token operator">-&gt;</span>EH
B<span class="token operator">-&gt;</span>FH
B<span class="token operator">-&gt;</span>CFH
B<span class="token operator">-&gt;</span>CEH
B<span class="token operator">-&gt;</span>EFH
C<span class="token operator">-&gt;</span>cY<span class="token punctuation">;</span>
D<span class="token operator">-&gt;</span>b<span class="token operator">=</span>a
E<span class="token operator">-&gt;</span>dX<span class="token punctuation">;</span>
F<span class="token operator">-&gt;</span>GB<span class="token punctuation">;</span>
G<span class="token operator">-&gt;</span>eb<span class="token punctuation">;</span>
H<span class="token operator">-&gt;</span>I
H<span class="token operator">-&gt;</span>R
H<span class="token operator">-&gt;</span>T
H<span class="token operator">-&gt;</span>S
H<span class="token operator">-&gt;</span>U
H<span class="token operator">-&gt;</span>V
H<span class="token operator">-&gt;</span>J
I<span class="token operator">-&gt;</span>btL
J<span class="token operator">-&gt;</span>fWg
K<span class="token operator">-&gt;</span>LQL
K<span class="token operator">-&gt;</span>hL
L<span class="token operator">-&gt;</span>LOM
L<span class="token operator">-&gt;</span>M
L<span class="token operator">-&gt;</span><span class="token operator">-</span>M
L<span class="token operator">-&gt;</span><span class="token operator">+</span>M
M<span class="token operator">-&gt;</span>MPN
M<span class="token operator">-&gt;</span>N
N<span class="token operator">-&gt;</span>b
N<span class="token operator">-&gt;</span>a
N<span class="token operator">-&gt;</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>
O<span class="token operator">-&gt;</span><span class="token operator">+</span>
O<span class="token operator">-&gt;</span><span class="token operator">-</span>
P<span class="token operator">-&gt;</span><span class="token operator">*</span>
P<span class="token operator">-&gt;</span><span class="token operator">/</span>
Q<span class="token operator">-&gt;</span><span class="token operator">=</span>
Q<span class="token operator">-&gt;</span><span class="token operator">%</span>
Q<span class="token operator">-&gt;</span><span class="token operator">&lt;</span>
Q<span class="token operator">-&gt;</span>r
Q<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>
Q<span class="token operator">-&gt;</span>s
R<span class="token operator">-&gt;</span>pKqH
S<span class="token operator">-&gt;</span>mb
T<span class="token operator">-&gt;</span>nKoH
U<span class="token operator">-&gt;</span><span class="token function">i</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>
V<span class="token operator">-&gt;</span><span class="token function">j</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span>
W<span class="token operator">-&gt;</span>W<span class="token punctuation">;</span>H
W<span class="token operator">-&gt;</span>H
X<span class="token operator">-&gt;</span>X<span class="token punctuation">,</span>b
X<span class="token operator">-&gt;</span>b
Y<span class="token operator">-&gt;</span>Y<span class="token punctuation">,</span>D
Y<span class="token operator">-&gt;</span>D
Z<span class="token operator">-&gt;</span>Z<span class="token punctuation">,</span>L
Z<span class="token operator">-&gt;</span>L</code></pre>
<p>我调试了一下程序，发现 2 个比较严重的 bug，有一个和程序无关紧要的 bug，后面再说，这里先说下其中的一个 bug，就是在求 <code>first</code> 集的 bug。</p>
<p>如果文法产生式有直接左递归的话，那么就会死递归爆栈，所以我对 <code>first</code> 集做了下简单的修改，就是遇到直接左递归，忽略掉。</p>
<p>另一个 <code>bug</code> 也处理好了，<code>PL0</code>测试通过，近 300 个状态，这里贴一下局部预览图感受下。
<img src="http://7xibui.com1.z0.glb.clouddn.com//2016/10/screenshot-window-2016-10-21-114458.png" alt="http://7xibui.com1.z0.glb.clouddn.com//2016/10/screenshot-window-2016-10-21-114458.png">
<img src="http://7xibui.com1.z0.glb.clouddn.com//2016/10/screenshot-window-2016-10-21-114315.png" alt="http://7xibui.com1.z0.glb.clouddn.com//2016/10/screenshot-window-2016-10-21-114315.png"></p>
<h2 id="for-auto-Bug"><code>for auto &amp;</code> Bug</h2>
<p>这个 <code>bug</code> 隐藏较深，就是我用 <code>auto</code> 引用类型引用容器中的元素，然后又在容器中插入元素，那么这个引用就会失效，换成迭代器也没达到预期效果，反而更糟，具体如下。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>只是简单地插入一个元素而已，输出结果却是这样的。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">i<span class="token operator">=</span><span class="token number">1</span>
i<span class="token operator">=</span><span class="token number">0</span>
i<span class="token operator">=</span><span class="token number">0</span>
i<span class="token operator">=</span><span class="token number">0</span>
i<span class="token operator">=</span><span class="token number">3</span>
i<span class="token operator">=</span><span class="token number">3</span></code></pre>
<p><code>i=0</code>是哪来的。。。这个没找出原因，最后简单的用 <code>for(int i=0; ...)</code> 来替代处理了。</p>
<p>现在找到原因了，看了下 <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/">cppreference.com</a> 关于 <code>push_back</code> 的定义，有这么一句话。</p>
<blockquote>
<p>If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
</blockquote>
<p>就是说如果 <code>vector</code> 插入元素的 <code>size()</code> 大于 <code>capacity()</code> 的话，所有迭代器、引用都会无效，否则只是最后一个元素的迭代器 / 引用无效。这个可能和 <code>vector</code> 内存分配管理有关。</p>
<p>然后就是打印了下 <code>vector</code> 的大小，发现刚开始 <code>size()==capacity()</code> 的，所以一插入元素就会出问题，用 <code>reserve()</code> 简单的把 <code>capacity()</code> 调大就没问题了。</p>
<h2 id="前端处理">前端处理</h2>
<p>核心程序写完了，最后就是把它展现出来，数据格式化下就好了。</p>
<p>之前在验收 <code>LL1</code> 实验的时候，老师看到我把语法树都画出来了，就说这个实验（<code>LL1</code>）没必要画语法树，<code>LR1</code>实验能把自动机画出来就好了，然后我就爽快答应了，因为只要核心程序写出来了，那么前端随便你怎么搞都行，这部分重点说下我是怎么画自动机的。</p>
<p>一开始我就是用 <code>mermaid</code> 这个 <code>JS</code> 库，只要给它图的描述，它就能画出来，试了下效果不是很满意。</p>
<p>继续 <code>Google</code>，发现这么一个工具<a target="_blank" rel="noopener" href="http://www.graphviz.org/">graphviz</a>，它用了一种很简单的<code>DOT</code> 语言，只要用 <code>DOT</code> 语言来描述这个图，它就能画出来。进一步发现这个工具有 <code>js</code> 移植版本，就试了试，效果不错，就是现在的样子。缺点就是这个移植版本太大了，<code>3.5MB</code>的库，所以第一次加载的时间全都花在下载这个库了，其二就是画那个 <code>PL0</code> 自动机的时候，会因为内存不足崩溃掉，可能这是 <code>JS</code> 的机制问题了吧。</p>
<p>考虑上面 2 个问题，我写了一个小程序 <code>LR_DFA</code>，用它在后台直接输出<code>DOT</code> 文件，然后交给 <code>graphviz</code> 处理导出 <code>pdf</code>，能把完整的<code>PL0</code> 自动机（画 <code>PL0</code> 比较耗时）画出来，就是前面贴出来的那个图了。</p>

    
  </div>

</article>


   
       <div class="original">
    <ul>
        <li>本文标题：编译原理实验之 LR(1) 分析器设计</li>
        <li>本文字数：2.7k</li>
        <li>本文作者：Netcan</li>
        <li>发布时间：2016年10月21日 - 21时15分</li>
        <li>最后更新：2022年12月09日 - 19时02分</li>
        <li>原始链接：<a href="https://netcan.github.io/2016/10/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B9%8BLR-1-%E5%88%86%E6%9E%90%E5%99%A8%E8%AE%BE%E8%AE%A1/">https://netcan.github.io/2016/10/21/编译原理实验之LR-1-分析器设计/</a></li>
        <li>版权声明：<i class="icon icon-cc"></i><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" rel="external nofollow noopener noreferrer" target="_blank">"署名-非商用-相同方式共享 3.0"</a>转载请保留原文链接及作者。</li>
    </ul>
</div>

   

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Netcan</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2016/10/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8BLL-1-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2016/12/15/%E6%B5%85%E8%B0%88Java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>
<script>
    $(".article-content img").wrap(function() {
        return '<a data-fancybox href="' + $(this).attr("src") + '"/>';
    });
</script>


  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '893a4103795fc66cd8e7',
  clientSecret: '35c92c3dca938831b67dc22e46d64bc9073ebacf',
  repo: 'netcan.github.io',
  owner: 'Netcan',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['Netcan'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
